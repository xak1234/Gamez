<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pac-Man</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body, html {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden; /* Prevent scrollbars from appearing due to slight overflows */
        }
        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative; /* For message box positioning */
            width: 100%;
        }
        canvas {
            display: block;
            background-color: #000;
            border: 2px solid #00f; /* Blue border like classic Pac-Man */
            max-width: 90vw; /* Ensure canvas doesn't exceed viewport width */
            max-height: 65vh; /* Adjust height to leave space for info and controls */
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            /* aspect-ratio will be handled by JS based on maze dimensions */
        }
        #gameInfo {
            width: 100%;
            /* max-width will be set by JS to match canvas width */
            display: flex;
            justify-content: space-between;
            padding: 10px 5px; /* Reduced padding slightly */
            font-size: 1rem;
            box-sizing: border-box;
        }
        #scoreBoard, #livesBoard, #levelBoard { /* Added levelBoard */
            color: #fff;
            margin: 0 5px; /* Add some spacing between elements */
        }
        #messageBox {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 20px; /* Reduced padding */
            border: 2px solid #ff0; /* Yellow border */
            border-radius: 10px;
            text-align: center;
            z-index: 100;
            display: none; /* Hidden by default */
            width: 80%;
            max-width: 400px; /* Max width for message box */
        }
        #messageBox h1 {
            font-size: 1.5rem; /* Adjusted font size */
            color: #ff0; /* Yellow title */
            margin-bottom: 10px;
        }
        #messageBox p {
            font-size: 0.9rem; /* Adjusted font size */
            margin-bottom: 15px;
            line-height: 1.4;
        }
        #messageBox button {
            background-color: #ff0; /* Yellow button */
            color: #000;
            border: none;
            padding: 10px 15px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.9rem; /* Adjusted font size */
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.2s;
        }
        #messageBox button:hover {
            background-color: #ffa500; /* Orange hover */
        }

        #touchControls {
            display: none; /* Hidden by default, shown for touch devices */
            margin-top: 10px;
            text-align: center;
        }
        #touchControls button {
            background-color: #333;
            color: #fff;
            border: 1px solid #fff;
            font-family: 'Press Start 2P', cursive;
            font-size: 1.2rem; /* Adjusted for better fit */
            padding: 8px; /* Adjusted padding */
            margin: 3px; /* Adjusted margin */
            min-width: 50px;
            min-height: 50px;
            border-radius: 8px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
        }
         @media (max-width: 600px) { /* More aggressive scaling for smaller screens */
            #gameInfo{
                font-size: 0.7rem;
                padding: 5px 2px;
            }
            #messageBox h1 { font-size: 1.2rem; }
            #messageBox p { font-size: 0.8rem; }
            #messageBox button { font-size: 0.8rem; padding: 8px 12px;}

            #touchControls {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                width: 180px; /* Smaller control pad */
                gap:3px;
            }
            #touchControls button {
                font-size: 1rem;
                min-width: 45px;
                min-height: 45px;
                padding: 6px;
            }
            #touchControls .up { grid-column: 2; }
            #touchControls .left { grid-column: 1; grid-row: 2; }
            #touchControls .right { grid-column: 3; grid-row: 2; }
            #touchControls .down { grid-column: 2; grid-row: 3; }
        }
        @media (orientation: landscape) and (max-height: 500px) {
             canvas {
                max-height: 80vh; /* Allow more height in landscape */
             }
             #gameInfo {
                font-size: 0.8rem;
             }
             #touchControls {
                margin-top: 5px;
                width: 150px;
             }
             #touchControls button {
                font-size: 0.9rem;
                min-width: 40px;
                min-height: 40px;
             }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="gameInfo">
            <div id="scoreBoard">Score: 0</div>
            <div id="levelBoard">Level: 1</div> <div id="livesBoard">Lives: 3</div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="messageBox">
            <h1 id="messageTitle">Game Over</h1>
            <p id="messageText">Your final score: <span id="finalScore">0</span></p>
            <button id="messageButton">Restart</button>
        </div>
    </div>
     <div id="touchControls">
        <button class="up" id="touchUp">⬆️</button>
        <button class="left" id="touchLeft">⬅️</button>
        <button class="right" id="touchRight">➡️</button>
        <button class="down" id="touchDown">⬇️</button>
    </div>

    <script>
        // Game DOM Elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreBoard = document.getElementById('scoreBoard');
        const livesBoard = document.getElementById('livesBoard');
        const levelBoard = document.getElementById('levelBoard');
        const finalScoreDisplay = document.getElementById('finalScore');
        const messageBox = document.getElementById('messageBox');
        const messageTitle = document.getElementById('messageTitle');
        const messageText = document.getElementById('messageText');
        let messageButton = document.getElementById('messageButton'); // Changed const to let

        // --- Audio Elements ---
        let audioInitialized = false;
        const sounds = {
            wakka: new Audio('wakka.mp3'),
            eatGhost: new Audio('eat_ghost.mp3'),
            death: new Audio('death.mp3'),
            // You can add more sounds here, e.g., powerPellet: new Audio('power_pellet.mp3')
        };

        // Function to play sound
        function playSound(soundName) {
            if (!audioInitialized) return; // Don't play if audio not yet allowed by user interaction
            const sound = sounds[soundName];
            if (sound) {
                sound.currentTime = 0; // Rewind to start
                sound.play().catch(error => console.warn(`Sound play failed for ${soundName}:`, error));
            } else {
                console.warn(`Sound not found: ${soundName}`);
            }
        }
        // Attempt to initialize (load) sounds. Playback will still require interaction.
        Object.values(sounds).forEach(sound => {
            sound.load();
            sound.volume = 0.5; // Adjust volume as needed (0.0 to 1.0)
        });


        // Game Constants and Variables
        const TILE_SIZE = 20; // Size of each tile in the maze
        let currentMazeLayout; // Holds the layout for the current level (the array of numbers)
        let mutableMaze; // Mutable copy of currentMazeLayout for tracking eaten pellets
        let pacman;
        let ghosts = [];
        let pellets = []; // Array of pellet objects {x, y, type, gridX, gridY}
        let score = 0;
        let lives = 3;
        let gameRunning = false;
        let frightenedMode = false; // Is Pac-Man powered up?
        let frightenedTimer = 0; // How long power-up lasts
        const FRIGHTENED_DURATION = 7000; // 7 seconds
        let currentLevelIndex = 0; // Start at level 1 (index 0)

        // --- MAZE DEFINITIONS ---
        // MAZE_LAYOUT_LEVEL_1: Original maze configuration
        const MAZE_LAYOUT_LEVEL_1 = {
            layout: [
                [1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1],
                [1,3,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,3,1],
                [1,2,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,2,1],
                [1,2,1,1,2,1,1,1,2,2,2,1,1,1,2,1,1,2,1],
                [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
                [1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,1,2,1],
                [1,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,1],
                [1,1,1,1,2,1,1,1,1,2,1,1,1,1,2,1,1,1,1],
                [1,1,1,1,2,1,1,1,4,2,2,2,2,2,2,1,0,0,0], // Ghost house (4), door (0), path (2)
                [1,1,1,1,2,1,1,1,1,2,1,1,1,1,2,1,1,1,1],
                [2,2,2,2,2,1,2,2,2,2,0,1,0,2,2,2,2,2,2], // Tunnel row
                [1,1,1,1,2,1,0,1,1,1,1,1,0,1,2,1,1,1,1],
                [2,2,2,2,2,1,0,0,2,5,0,0,0,1,2,2,2,2,2], // Pacman start (5), Tunnel row
                [1,1,1,1,2,1,0,1,2,1,1,1,0,1,2,1,1,1,1],
                [2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2], // Tunnel row
                [1,2,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,2,1],
                [1,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1],
                [1,1,2,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1],
                [1,3,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,3,1],
                [1,2,1,1,1,1,1,1,2,1,2,1,1,1,1,1,1,2,1],
                [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
                [1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1]
            ],
            tunnelRows: [10, 12, 14], // Row indices (0-based) that contain tunnels
            ghostDoorPos: { x: 9, y: 7 } // Grid coordinates of the ghost house door (tile type 0)
        };

        // --------------- START: PASTE YOUR LEVEL 2 MAZE ARRAY HERE ---------------
        // IMPORTANT: Replace the 'layout', 'tunnelRows', and 'ghostDoorPos' with your actual Level 2 data.
        const MAZE_LAYOUT_LEVEL_2 = {
            layout: [ // THIS IS A PLACEHOLDER - REPLACE IT!
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,5,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,3,1],
                [1,2,1,1,1,2,1,1,1,1,1,2,1,2,1,1,1,1,1,2,1,1,1,2,1],
                [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
                [1,2,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,2,1,2,1,1,1,2,1],
                [1,2,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,1],
                [1,1,1,1,1,2,1,1,1,2,1,2,1,2,1,2,1,1,1,2,1,1,1,1,1],
                [0,0,0,0,1,2,1,2,2,2,1,2,1,2,1,2,2,2,1,2,1,0,0,0,0],
                [1,1,1,1,1,2,1,2,1,1,1,0,0,0,1,1,1,2,1,2,1,1,1,1,1],
                [1,2,2,2,2,2,2,2,1,4,4,4,4,4,4,1,2,2,2,2,2,2,2,2,1],
                [1,2,1,1,1,2,1,2,1,4,1,1,0,1,1,4,1,2,1,2,1,1,1,2,1],
                [1,2,1,1,1,2,1,2,1,4,1,2,2,2,1,4,1,2,1,2,1,1,1,2,1],
                [1,2,2,2,2,2,1,2,1,4,4,4,4,4,4,1,2,1,2,2,2,2,2,2,1],
                [1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,2,1,2,1,1,1,1,1],
                [1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1],
                [1,2,1,1,1,2,1,1,1,1,1,2,1,2,1,1,1,1,1,2,1,1,1,2,1],
                [1,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ],
            tunnelRows: [7],
            ghostDoorPos: { x: 12, y: 10 }
        };
        // --------------- END: PASTE YOUR LEVEL 2 MAZE ARRAY HERE ---------------

        const allMazeConfigs = [MAZE_LAYOUT_LEVEL_1, MAZE_LAYOUT_LEVEL_2];
        let currentTunnelRows;
        let currentGhostDoorPos;


        function loadLevelConfig(levelIndex) {
            if (levelIndex >= allMazeConfigs.length) {
                console.warn("Attempted to load invalid level index:", levelIndex);
                return false;
            }
            const config = allMazeConfigs[levelIndex];
            currentMazeLayout = config.layout;
            currentTunnelRows = config.tunnelRows || [];
            currentGhostDoorPos = config.ghostDoorPos;

            if (!currentMazeLayout || currentMazeLayout.length === 0 || !currentMazeLayout[0] || currentMazeLayout[0].length === 0) {
                console.error("Maze layout is invalid for level:", levelIndex, currentMazeLayout);
                showMessage("Error", "Failed to load level data.<br>Maze layout is invalid.", "Restart", () => initGame(true));
                return false;
            }
            if (!currentGhostDoorPos || typeof currentGhostDoorPos.x !== 'number' || typeof currentGhostDoorPos.y !== 'number') {
                console.error("Ghost door position not properly defined for level:", levelIndex);
                let foundDoor = false;
                for (let r = 0; r < currentMazeLayout.length; r++) {
                    for (let c = 0; c < currentMazeLayout[0].length; c++) {
                        if (currentMazeLayout[r][c] === 0) {
                            currentGhostDoorPos = { x: c, y: r };
                            foundDoor = true; break;
                        }
                    }
                    if (foundDoor) break;
                }
                if (!foundDoor) currentGhostDoorPos = { x: Math.floor(currentMazeLayout[0].length / 2) , y: Math.floor(currentMazeLayout.length / 2) -1 };
                console.warn("Using fallback ghost door position:", currentGhostDoorPos);
            }
            return true;
        }

        function resizeCanvas() {
            if (!currentMazeLayout || currentMazeLayout.length === 0 || !currentMazeLayout[0] || currentMazeLayout[0].length === 0) {
                console.warn("Cannot resize canvas, maze layout is not ready.");
                return;
            }
            const mazePixelWidth = currentMazeLayout[0].length * TILE_SIZE;
            const mazePixelHeight = currentMazeLayout.length * TILE_SIZE;

            canvas.width = mazePixelWidth;
            canvas.height = mazePixelHeight;

            const containerWidth = document.getElementById('gameContainer').clientWidth * 0.9;
            const containerHeight = window.innerHeight * 0.65;

            const scale = Math.min(containerWidth / mazePixelWidth, containerHeight / mazePixelHeight, 1);

            canvas.style.width = (mazePixelWidth * scale) + 'px';
            canvas.style.height = (mazePixelHeight * scale) + 'px';

            const gameInfo = document.getElementById('gameInfo');
            if (gameInfo) {
                gameInfo.style.width = (mazePixelWidth * scale) + 'px';
                gameInfo.style.maxWidth = (mazePixelWidth * scale) + 'px';
            }
        }
        window.addEventListener('resize', resizeCanvas);

        class PacMan {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.spawnX = x; this.spawnY = y;
                this.radius = TILE_SIZE / 2 - 2; this.speed = 2;
                this.dx = 0; this.dy = 0; this.nextDx = 0; this.nextDy = 0;
                this.mouthOpen = true; this.mouthAngle = 0.2 * Math.PI; this.mouthSpeed = 0.05 * Math.PI;
                this.color = '#ff0';
            }
            draw() {
                ctx.fillStyle = this.color; ctx.beginPath();
                const angle = (this.dx === 0 && this.dy === 0 && this.nextDx === 0 && this.nextDy === 0) ? 0 : Math.atan2(this.dy || this.nextDy, this.dx || this.nextDx);
                ctx.arc(this.x + TILE_SIZE / 2, this.y + TILE_SIZE / 2, this.radius, angle + this.mouthAngle, angle - this.mouthAngle);
                ctx.lineTo(this.x + TILE_SIZE / 2, this.y + TILE_SIZE / 2); ctx.fill();
                if (this.mouthOpen) { this.mouthAngle += this.mouthSpeed; if (this.mouthAngle >= 0.4 * Math.PI) this.mouthOpen = false; }
                else { this.mouthAngle -= this.mouthSpeed; if (this.mouthAngle <= 0.05 * Math.PI) this.mouthOpen = true; }
            }
            update() {
                const onGridXStrict = (this.x % TILE_SIZE === 0);
                const onGridYStrict = (this.y % TILE_SIZE === 0);
                if (this.nextDx !== 0 || this.nextDy !== 0) {
                    if (this.nextDx !== 0 && onGridYStrict) {
                        const checkY = this.y / TILE_SIZE;
                        const checkX = Math.floor((this.x + this.nextDx * TILE_SIZE) / TILE_SIZE);
                        if (!this.isWall(checkX, checkY, true)) { this.dx = this.nextDx; this.dy = 0; this.nextDx = 0; this.nextDy = 0; }
                    } else if (this.nextDy !== 0 && onGridXStrict) {
                        const checkX = this.x / TILE_SIZE;
                        const checkY = Math.floor((this.y + this.nextDy * TILE_SIZE) / TILE_SIZE);
                        if (!this.isWall(checkX, checkY, true)) { this.dx = 0; this.dy = this.nextDy; this.nextDx = 0; this.nextDy = 0; }
                    }
                }
                const targetX = this.x + this.dx * this.speed; const targetY = this.y + this.dy * this.speed;
                const currentTileX = Math.floor(this.x / TILE_SIZE); const currentTileY = Math.floor(this.y / TILE_SIZE);
                if (this.dx !== 0) {
                    const nextWallCheckX = Math.floor((targetX + (this.dx > 0 ? TILE_SIZE - 0.1 : 0.1)) / TILE_SIZE);
                    if (!this.isWall(nextWallCheckX, currentTileY, false)) this.x = targetX;
                    else this.x = Math.round(this.x / TILE_SIZE) * TILE_SIZE;
                }
                if (this.dy !== 0) {
                    const nextWallCheckY = Math.floor((targetY + (this.dy > 0 ? TILE_SIZE - 0.1 : 0.1)) / TILE_SIZE);
                    if (!this.isWall(currentTileX, nextWallCheckY, false)) this.y = targetY;
                    else this.y = Math.round(this.y / TILE_SIZE) * TILE_SIZE;
                }
                const characterGridY = Math.floor(this.y / TILE_SIZE);
                const characterPixelYOnGrid = characterGridY * TILE_SIZE;
                const isVerticallyAlignedForTunnel = (Math.abs(this.y - characterPixelYOnGrid) < this.speed);
                if (currentTunnelRows.includes(characterGridY) && isVerticallyAlignedForTunnel) {
                    if (this.y !== characterPixelYOnGrid) this.y = characterPixelYOnGrid;
                    if (this.x <= -TILE_SIZE && this.dx < 0) this.x = canvas.width - TILE_SIZE;
                    else if (this.x >= canvas.width && this.dx > 0) this.x = 0;
                }
                this.eatPellet();
            }
            isWall(gridX, gridY, isTurning) {
                const x = Math.floor(gridX); const y = Math.floor(gridY);
                const currentGridY = Math.floor(this.y / TILE_SIZE);
                const isVerticallyAlignedEnough = Math.abs(this.y - (currentGridY * TILE_SIZE)) < this.speed;
                if (currentTunnelRows.includes(currentGridY) && isVerticallyAlignedEnough && !isTurning) {
                    if ((x < 0 && this.dx < 0) || (x >= currentMazeLayout[0].length && this.dx > 0)) return false;
                }
                if (y < 0 || y >= currentMazeLayout.length || x < 0 || x >= currentMazeLayout[0].length) return true;
                const tileType = currentMazeLayout[y][x];
                return tileType === 1 || tileType === 4;
            }
            setDirection(dx, dy) { this.nextDx = dx; this.nextDy = dy; }
            eatPellet() {
                const gridX = Math.floor((this.x + TILE_SIZE / 2) / TILE_SIZE);
                const gridY = Math.floor((this.y + TILE_SIZE / 2) / TILE_SIZE);
                if (gridY >= 0 && gridY < mutableMaze.length && gridX >= 0 && gridX < mutableMaze[0].length) {
                    const tile = mutableMaze[gridY][gridX];
                    if (tile === 2 || tile === 3) {
                        mutableMaze[gridY][gridX] = 0;
                        pellets = pellets.filter(p => !(p.gridX === gridX && p.gridY === gridY));
                        score += (tile === 2 ? 10 : 50);
                        updateScoreboard();
                        if (tile === 2) playSound('wakka'); // Play wakka for normal pellet
                        if (tile === 3) {
                            // playSound('powerPellet'); // Optional: Add a specific sound for power pellets
                            frightenedMode = true; frightenedTimer = FRIGHTENED_DURATION;
                            ghosts.forEach(g => g.enterFrightenedMode());
                        }
                        if (pellets.length === 0) gameWon();
                    }
                }
            }
        }

        class Ghost {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.spawnX = x; this.spawnY = y;
                this.radius = TILE_SIZE / 2 - 3; this.speed = 1.8;
                this.dx = 0; this.dy = -1; this.color = color; this.originalColor = color;
                this.frightenedColor = '#00f'; this.isFrightened = false; this.isEaten = false;
                this.eatenColor = '#aaa'; this.isInsideHouse = true;
                this.doorTarget = { x: currentGhostDoorPos.x * TILE_SIZE, y: currentGhostDoorPos.y * TILE_SIZE };
            }
            draw() {
                let drawColor = this.originalColor;
                if (this.isEaten) { drawColor = this.eatenColor;
                } else if (this.isFrightened) {
                    if (frightenedTimer < 2000 && Math.floor(frightenedTimer / 250) % 2 === 0) drawColor = '#fff';
                    else drawColor = this.frightenedColor;
                }
                ctx.fillStyle = drawColor; ctx.beginPath();
                ctx.arc(this.x + TILE_SIZE / 2, this.y + TILE_SIZE / 2, this.radius, Math.PI, 0);
                const base = this.y + TILE_SIZE / 2 + this.radius;
                ctx.lineTo(this.x + TILE_SIZE, base); ctx.lineTo(this.x + TILE_SIZE * 0.8, base - TILE_SIZE * 0.2);
                ctx.lineTo(this.x + TILE_SIZE * 0.6, base); ctx.lineTo(this.x + TILE_SIZE * 0.4, base - TILE_SIZE * 0.2);
                ctx.lineTo(this.x + TILE_SIZE * 0.2, base); ctx.lineTo(this.x, base); ctx.closePath(); ctx.fill();
                if (!this.isEaten) {
                    ctx.fillStyle = '#fff'; const eyeRadius = this.radius * 0.3;
                    const eyeOffsetX = this.radius * 0.35; const eyeOffsetY = -this.radius * 0.05;
                    ctx.beginPath();
                    ctx.arc(this.x + TILE_SIZE / 2 - eyeOffsetX, this.y + TILE_SIZE / 2 + eyeOffsetY, eyeRadius, 0, 2 * Math.PI);
                    ctx.arc(this.x + TILE_SIZE / 2 + eyeOffsetX, this.y + TILE_SIZE / 2 + eyeOffsetY, eyeRadius, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.fillStyle = '#000'; const pupilRadius = eyeRadius * 0.5;
                    let pDx = this.dx; let pDy = this.dy;
                    if (this.isFrightened && Math.random() < 0.05) {pDx = Math.floor(Math.random()*3)-1; pDy = Math.floor(Math.random()*3)-1; if(pDx===0 && pDy===0)pDx=1;}
                    const pOffsetX = pDx * pupilRadius * 0.6; const pOffsetY = pDy * pupilRadius * 0.6;
                    ctx.beginPath();
                    ctx.arc(this.x + TILE_SIZE / 2 - eyeOffsetX + pOffsetX, this.y + TILE_SIZE / 2 + eyeOffsetY + pOffsetY, pupilRadius, 0, 2*Math.PI);
                    ctx.arc(this.x + TILE_SIZE / 2 + eyeOffsetX + pOffsetX, this.y + TILE_SIZE / 2 + eyeOffsetY + pOffsetY, pupilRadius, 0, 2*Math.PI);
                    ctx.fill();
                } else {
                    ctx.fillStyle = '#000'; const eyeR = this.radius*0.2; ctx.beginPath();
                    ctx.arc(this.x+TILE_SIZE/2-eyeR, this.y+TILE_SIZE/2-eyeR*0.5, eyeR*0.7,0,2*Math.PI);
                    ctx.arc(this.x+TILE_SIZE/2+eyeR, this.y+TILE_SIZE/2-eyeR*0.5, eyeR*0.7,0,2*Math.PI); ctx.fill();
                }
            }
            update() {
                const onGrid = (Math.abs(this.x % TILE_SIZE) < this.speed && Math.abs(this.x % TILE_SIZE) > -this.speed) &&
                               (Math.abs(this.y % TILE_SIZE) < this.speed && Math.abs(this.y % TILE_SIZE) > -this.speed);
                let targetPixelX = this.x, targetPixelY = this.y;
                if (this.isEaten) {
                    targetPixelX = this.spawnX; targetPixelY = this.spawnY;
                    if (Math.abs(this.x - targetPixelX) < this.speed && Math.abs(this.y - targetPixelY) < this.speed) {
                        this.x = targetPixelX; this.y = targetPixelY; this.isEaten = false; this.isInsideHouse = true; this.speed = 1.8;
                        this.dx = 0; this.dy = -1; return;
                    }
                } else if (this.isInsideHouse) {
                    targetPixelX = this.doorTarget.x; targetPixelY = this.doorTarget.y;
                    if (this.y <= targetPixelY && Math.abs(this.x - targetPixelX) < this.speed ) {
                         this.x = targetPixelX; this.y = targetPixelY; this.isInsideHouse = false;
                         this.dx = Math.random() < 0.5 ? -1 : 1; this.dy = 0;
                         const exitCheckX = Math.floor((this.x + this.dx * TILE_SIZE) / TILE_SIZE);
                         const exitCheckY = Math.floor(this.y / TILE_SIZE);
                         if (this.isWall(exitCheckX, exitCheckY, true)) {
                            this.dx *= -1;
                            const secondExitCheckX = Math.floor((this.x + this.dx * TILE_SIZE) / TILE_SIZE);
                            if (this.isWall(secondExitCheckX, exitCheckY, true)) { this.dy = -1; this.dx = 0; }
                         } return;
                    }
                }
                if (onGrid) {
                     this.x = Math.round(this.x / TILE_SIZE) * TILE_SIZE;
                     this.y = Math.round(this.y / TILE_SIZE) * TILE_SIZE;
                    if (this.isEaten || this.isInsideHouse) {
                        const diffX = targetPixelX - this.x; const diffY = targetPixelY - this.y;
                        let preferredDx = 0, preferredDy = 0;
                        if (this.isInsideHouse && this.y > targetPixelY) preferredDy = -1;
                        else if (this.isInsideHouse && this.x !== targetPixelX) preferredDx = Math.sign(targetPixelX - this.x);
                        else if (Math.abs(diffY) > Math.abs(diffX) && diffY !== 0) preferredDy = Math.sign(diffY);
                        else if (diffX !== 0) preferredDx = Math.sign(diffX);
                        else if (diffY !== 0) preferredDy = Math.sign(diffY);
                        if (preferredDy !== 0 && !this.isWall(this.x/TILE_SIZE, (this.y + preferredDy*TILE_SIZE)/TILE_SIZE, true)) { this.dx = 0; this.dy = preferredDy; }
                        else if (preferredDx !== 0 && !this.isWall((this.x + preferredDx*TILE_SIZE)/TILE_SIZE, this.y/TILE_SIZE, true)) { this.dx = preferredDx; this.dy = 0; }
                        else {
                            const availableMoves = this.getAvailableMoves();
                            if(availableMoves.length > 0){ const move = availableMoves[Math.floor(Math.random() * availableMoves.length)]; this.dx = move.dx; this.dy = move.dy; }
                            else { this.dx = 0; this.dy = 0;}
                        }
                    } else {
                        const availableMoves = this.getAvailableMoves(); let chosenMoves = availableMoves;
                        if (!this.isFrightened) {
                            chosenMoves = availableMoves.filter(m => !(m.dx === -this.dx && m.dy === -this.dy && availableMoves.length > 1) );
                            if (chosenMoves.length === 0 && availableMoves.length > 0) chosenMoves = availableMoves;
                        }
                        if (chosenMoves.length > 0) { const move = chosenMoves[Math.floor(Math.random() * chosenMoves.length)]; this.dx = move.dx; this.dy = move.dy; }
                        else { this.dx = 0; this.dy = 0; }
                    }
                }
                const currentActualSpeed = this.isFrightened && !this.isEaten ? this.speed * 0.65 : (this.isEaten ? this.speed * 2.5 : this.speed);
                const nextX = this.x + this.dx * currentActualSpeed; const nextY = this.y + this.dy * currentActualSpeed;
                if (this.dx !== 0) {
                    const wallCheckGridX = Math.floor((nextX + (this.dx > 0 ? TILE_SIZE - 0.1 : 0.1)) / TILE_SIZE);
                    const currentGridY = Math.floor(this.y / TILE_SIZE);
                    if (!this.isWall(wallCheckGridX, currentGridY, false)) this.x = nextX;
                    else { this.x = Math.round(this.x / TILE_SIZE) * TILE_SIZE; if (!this.isEaten && !this.isInsideHouse) {this.dx=0; this.dy=0;}}
                }
                if (this.dy !== 0) {
                    const wallCheckGridY = Math.floor((nextY + (this.dy > 0 ? TILE_SIZE - 0.1 : 0.1)) / TILE_SIZE);
                    const currentGridX = Math.floor(this.x / TILE_SIZE);
                    if (!this.isWall(currentGridX, wallCheckGridY, false)) this.y = nextY;
                    else { this.y = Math.round(this.y / TILE_SIZE) * TILE_SIZE; if (!this.isEaten && !this.isInsideHouse) {this.dx=0; this.dy=0;}}
                }
                const characterGridY = Math.floor(this.y / TILE_SIZE);
                const characterPixelYOnGrid = characterGridY * TILE_SIZE;
                const isVerticallyAlignedForTunnel = (Math.abs(this.y - characterPixelYOnGrid) < currentActualSpeed);
                if (currentTunnelRows.includes(characterGridY) && isVerticallyAlignedForTunnel && !this.isInsideHouse && !this.isEaten) {
                     if (Math.abs(this.y - characterPixelYOnGrid) > 0.1) this.y = characterPixelYOnGrid;
                    if (this.x <= -TILE_SIZE && this.dx < 0) this.x = canvas.width - TILE_SIZE;
                    else if (this.x >= canvas.width && this.dx > 0) this.x = 0;
                }
            }
            getAvailableMoves() {
                const moves = []; const currentGridX = this.x / TILE_SIZE; const currentGridY = this.y / TILE_SIZE;
                if (!this.isWall(currentGridX, currentGridY - 1, true)) moves.push({dx:0, dy:-1});
                if (!this.isWall(currentGridX, currentGridY + 1, true)) moves.push({dx:0, dy:1});
                if (!this.isWall(currentGridX - 1, currentGridY, true)) moves.push({dx:-1, dy:0});
                if (!this.isWall(currentGridX + 1, currentGridY, true)) moves.push({dx:1, dy:0});
                return moves;
            }
            isWall(gridX, gridY, isTurningLogic) {
                const x = Math.floor(gridX); const y = Math.floor(gridY);
                if (!this.isEaten && !this.isInsideHouse) {
                    const currentGhostGridY = Math.floor(this.y / TILE_SIZE);
                    const isVerticallyAlignedEnough = Math.abs(this.y - (currentGhostGridY * TILE_SIZE)) < this.speed;
                    if (currentTunnelRows.includes(currentGhostGridY) && isVerticallyAlignedEnough && !isTurningLogic) {
                        if ((x < 0 && this.dx < 0) || (x >= currentMazeLayout[0].length && this.dx > 0)) return false;
                    }
                }
                if (y < 0 || y >= currentMazeLayout.length || x < 0 || x >= currentMazeLayout[0].length) return true;
                const tileType = currentMazeLayout[y][x];
                if (x === currentGhostDoorPos.x && y === currentGhostDoorPos.y && tileType === 0) return false;
                if (tileType === 4 && (this.isEaten || this.isInsideHouse)) return false;
                return tileType === 1;
            }
            enterFrightenedMode() {
                if (!this.isEaten) {
                    this.isFrightened = true;
                    const onGrid = (Math.abs(this.x % TILE_SIZE) < this.speed) && (Math.abs(this.y % TILE_SIZE) < this.speed);
                    if (onGrid && (this.dx !== 0 || this.dy !== 0) && !this.isInsideHouse) { this.dx *= -1; this.dy *= -1; }
                }
            }
            getEaten() {
                if (this.isFrightened) {
                    playSound('eatGhost');
                    this.isEaten = true; this.isFrightened = false;
                    score += 200 * (ghosts.filter(g => g.isEaten && g.isFrightened === false).length);
                    updateScoreboard();
                }
            }
        }

        function initMazeAndEntities() {
            mutableMaze = JSON.parse(JSON.stringify(currentMazeLayout));
            pellets = []; ghosts = []; pacman = null;
            const ghostColors = ['#f00', '#0ff', '#f8b', '#fa0'];
            let ghostSpawnCoords = []; let pacmanSpawnPos = {x: -1, y: -1};
            for (let y = 0; y < currentMazeLayout.length; y++) {
                for (let x = 0; x < currentMazeLayout[0].length; x++) {
                    const tileType = currentMazeLayout[y][x];
                    if (tileType === 2) pellets.push({ x: x * TILE_SIZE + TILE_SIZE / 2, y: y * TILE_SIZE + TILE_SIZE / 2, type: 'normal', gridX: x, gridY: y });
                    else if (tileType === 3) pellets.push({ x: x * TILE_SIZE + TILE_SIZE / 2, y: y * TILE_SIZE + TILE_SIZE / 2, type: 'power', gridX: x, gridY: y });
                    else if (tileType === 5) pacmanSpawnPos = {x: x * TILE_SIZE, y: y * TILE_SIZE};
                    else if (tileType === 4) ghostSpawnCoords.push({x: x * TILE_SIZE, y: y * TILE_SIZE});
                }
            }
            if (pacmanSpawnPos.x === -1) {
                console.warn("PacMan spawn (5) not found. Placing at default/first empty.");
                let foundEmpty = false;
                for (let r = 0; r < currentMazeLayout.length; r++) {
                    for (let c = 0; c < currentMazeLayout[0].length; c++) {
                        if(currentMazeLayout[r][c] !== 1 && currentMazeLayout[r][c] !== 4){ pacmanSpawnPos = {x: c*TILE_SIZE, y: r*TILE_SIZE}; foundEmpty=true; break; }
                    } if(foundEmpty)break;
                }
                if(!foundEmpty) pacmanSpawnPos = {x: TILE_SIZE, y: TILE_SIZE};
            }
            pacman = new PacMan(pacmanSpawnPos.x, pacmanSpawnPos.y);
            if (ghostSpawnCoords.length === 0) {
                console.warn("Ghost spawn (4) not found. Spawning near door.");
                for(let i=0; i < ghostColors.length; i++) {
                    ghostSpawnCoords.push({ x: currentGhostDoorPos.x * TILE_SIZE + (i%2===0 ? -TILE_SIZE:TILE_SIZE), y: (currentGhostDoorPos.y + 1 + Math.floor(i/2)) * TILE_SIZE });
                }
            }
            ghostColors.forEach((color, index) => {
                const spawnPos = ghostSpawnCoords[index % ghostSpawnCoords.length];
                ghosts.push(new Ghost(spawnPos.x, spawnPos.y, color));
            });
            resizeCanvas();
        }

        function drawMaze() {
            if (!currentMazeLayout) return;
            ctx.fillStyle = '#00f';
            for (let y = 0; y < currentMazeLayout.length; y++) {
                for (let x = 0; x < currentMazeLayout[0].length; x++) {
                    if (currentMazeLayout[y][x] === 1) ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }
        }
        function drawPellets() {
             pellets.forEach(pellet => {
                const originalTileType = currentMazeLayout[pellet.gridY][pellet.gridX];
                if (originalTileType === 3) ctx.fillStyle = '#FFA500'; else ctx.fillStyle = '#fff';
                ctx.beginPath();
                const radius = originalTileType === 3 ? TILE_SIZE / 3 : TILE_SIZE / 6;
                ctx.arc(pellet.x, pellet.y, radius, 0, 2 * Math.PI); ctx.fill();
            });
        }

        function updateScoreboard() { scoreBoard.textContent = `Score: ${score}`; }
        function updateLivesBoard() { livesBoard.textContent = `Lives: ${lives}`; }
        function updateLevelBoard() { levelBoard.textContent = `Level: ${currentLevelIndex + 1}`; }

        function showMessage(title, text, buttonText, onButtonClick) {
            messageTitle.textContent = title;
            messageText.innerHTML = text;
            let currentMsgButton = document.getElementById('messageButton');
            currentMsgButton.textContent = buttonText;
            messageBox.style.display = 'block';
            const newButton = currentMsgButton.cloneNode(true);
            currentMsgButton.parentNode.replaceChild(newButton, currentMsgButton);
            messageButton = newButton;
            messageButton.onclick = () => {
                hideMessage();
                if (!audioInitialized) audioInitialized = true; // Allow sounds after first interaction
                if (onButtonClick) onButtonClick();
            };
        }
        function hideMessage() { messageBox.style.display = 'none'; }

        function resetPlayerAndGhosts() {
            if (!pacman) { console.error("Pacman not initialized."); return; }
            pacman.x = pacman.spawnX; pacman.y = pacman.spawnY;
            pacman.dx = 0; pacman.dy = 0; pacman.nextDx = 0; pacman.nextDy = 0;
            pacman.mouthAngle = 0.2 * Math.PI;
            ghosts.forEach(g => {
                g.x = g.spawnX; g.y = g.spawnY; g.isFrightened = false; g.isEaten = false;
                g.isInsideHouse = true; g.dx = 0; g.dy = -1;
                g.doorTarget = { x: currentGhostDoorPos.x * TILE_SIZE, y: currentGhostDoorPos.y * TILE_SIZE };
            });
            frightenedMode = false; frightenedTimer = 0;
        }

        function checkCollisions() {
            if (!pacman || !gameRunning) return;
            ghosts.forEach(ghost => {
                if (ghost.isEaten) return;
                const distX = (pacman.x + TILE_SIZE/2) - (ghost.x + TILE_SIZE/2);
                const distY = (pacman.y + TILE_SIZE/2) - (ghost.y + TILE_SIZE/2);
                const distance = Math.sqrt(distX * distX + distY * distY);
                if (distance < pacman.radius + ghost.radius - (TILE_SIZE * 0.2)) {
                    if (ghost.isFrightened) {
                        ghost.getEaten(); // Sound is played within getEaten
                    } else {
                        playSound('death');
                        lives--; updateLivesBoard(); gameRunning = false;
                        if (lives <= 0) gameOver();
                        else {
                            showMessage("Caught!", `Lives left: ${lives}<br>Try again!`, "OK", () => {
                                resetPlayerAndGhosts(); gameRunning = true;
                            });
                        }
                    }
                }
            });
        }

        function startGameFlow(isInitialStart = false) {
            if (!loadLevelConfig(currentLevelIndex)) {
                showMessage("YOU WIN!", `Congratulations! You beat all ${allMazeConfigs.length} levels!<br>Final Score: ${score}`, "Play Again From Level 1", () => {
                    currentLevelIndex = 0; score = 0; lives = 3;
                    initGame(true);
                }); return;
            }
            initMazeAndEntities(); resetPlayerAndGhosts();
            updateScoreboard(); updateLivesBoard(); updateLevelBoard();
            hideMessage(); gameRunning = true;
            if(isInitialStart) { lastTime = performance.now(); requestAnimationFrame(gameLoop); }
            else { lastTime = performance.now(); }
        }

        function initGame(isNewFullGame = false) {
            if (isNewFullGame || lives <= 0) { score = 0; lives = 3; currentLevelIndex = 0; }
            startGameFlow(isNewFullGame);
        }

        function gameOver() {
            gameRunning = false; finalScoreDisplay.textContent = score;
            showMessage("Game Over", `Your final score: ${score}<br>Reached Level: ${currentLevelIndex + 1}`, "Restart Game", () => initGame(true));
        }

        function gameWon() {
            gameRunning = false; currentLevelIndex++;
            if (currentLevelIndex < allMazeConfigs.length) {
                showMessage(`Level ${currentLevelIndex} Cleared!`, `Score: ${score}<br>Get Ready for Level ${currentLevelIndex + 1}!`, "Next Level", () => startGameFlow(false));
            } else {
                showMessage("YOU WIN!", `Congratulations! You beat all levels!<br>Final Score: ${score}`, "Play Again", () => initGame(true));
            }
        }

        let lastTime = 0; const GHOST_UPDATE_INTERVAL = 100; let ghostUpdateTimer = 0;
        function gameLoop(timestamp) {
            if (!gameRunning && messageBox.style.display !== 'none') { requestAnimationFrame(gameLoop); return; }
            if (!gameRunning && messageBox.style.display === 'none' && lives > 0) { requestAnimationFrame(gameLoop); return; }
            if (!currentMazeLayout || !pacman) { console.warn("Loop before init."); requestAnimationFrame(gameLoop); return; }

            const deltaTime = timestamp - lastTime; lastTime = timestamp;
            const effectiveDeltaTime = Math.min(deltaTime, 100);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawMaze(); drawPellets();
            pacman.update(); pacman.draw();
            ghostUpdateTimer += effectiveDeltaTime;
            if(ghostUpdateTimer >= GHOST_UPDATE_INTERVAL){ ghosts.forEach(ghost => ghost.update()); ghostUpdateTimer = 0; }
            ghosts.forEach(ghost => ghost.draw());
            if (gameRunning) checkCollisions();
            if (frightenedMode) {
                frightenedTimer -= effectiveDeltaTime;
                if (frightenedTimer <= 0) {
                    frightenedMode = false;
                    ghosts.forEach(g => { if (!g.isEaten) g.isFrightened = false; });
                }
            }
            requestAnimationFrame(gameLoop);
        }

        window.addEventListener('keydown', (e) => {
            if (messageBox.style.display !== 'none') {
                if (e.key === "Enter" || e.key === " ") { messageButton.click(); e.preventDefault(); }
                return;
            }
            if (!gameRunning || !pacman) return;
            switch (e.key) {
                case 'ArrowUp': case 'w': case 'W': pacman.setDirection(0, -1); e.preventDefault(); break;
                case 'ArrowDown': case 's': case 'S': pacman.setDirection(0, 1); e.preventDefault(); break;
                case 'ArrowLeft': case 'a': case 'A': pacman.setDirection(-1, 0); e.preventDefault(); break;
                case 'ArrowRight': case 'd': case 'D': pacman.setDirection(1, 0); e.preventDefault(); break;
            }
        });

        const touchControlsDiv = document.getElementById('touchControls');
        function isTouchDevice() { return ('ontouchstart' in window) || (navigator.maxTouchPoints > 0); }
        if (isTouchDevice()) {
            touchControlsDiv.style.display = 'grid';
            const handleTouchControl = (dx, dy) => {
                if (messageBox.style.display !== 'none') {
                    messageButton.click(); return;
                }
                if (!audioInitialized) audioInitialized = true; // Also allow sounds on touch interaction
                if (gameRunning && pacman) pacman.setDirection(dx, dy);
            };
            document.getElementById('touchUp').addEventListener('click', () => handleTouchControl(0, -1));
            document.getElementById('touchDown').addEventListener('click', () => handleTouchControl(0, 1));
            document.getElementById('touchLeft').addEventListener('click', () => handleTouchControl(-1, 0));
            document.getElementById('touchRight').addEventListener('click', () => handleTouchControl(1, 0));
        }

        showMessage("Pac-Man", "Use Arrow Keys or Tap Controls to Move.<br>Eat all pellets to win!", "Start Game", () => {
            // audioInitialized is set to true here, after the first user click.
            initGame(true);
        });
    </script>
</body>
</html>
