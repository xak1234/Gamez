
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Anal Command</title>
    <style>
        body {
            background: #000;
            color: #0ff;
            font-family: 'Press Start 2P', monospace, sans-serif;
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
            margin: 0 auto;
            background: #000;
        }
        #score {
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 30px;
            color: #0090ff;
            letter-spacing: 3px;
            font-family: 'Press Start 2P', monospace, sans-serif;
            text-shadow: 1px 1px #111, 0 0 8px #22f;
        }
    </style>
</head>
<body>
<div id="score"></div>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<audio id="sndLaunch" src="https://cdn.pixabay.com/audio/2022/07/26/audio_12ccefa48c.mp3" preload="auto"></audio>
<audio id="sndExplosion" src="https://cdn.pixabay.com/audio/2022/07/26/audio_123ef6f88d.mp3" preload="auto"></audio>
<audio id="sndLose" src="https://cdn.pixabay.com/audio/2022/07/26/audio_124b6a3a44.mp3" preload="auto"></audio>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const w = canvas.width, h = canvas.height;

const CITY_NAMES = ["LEEDS", "YORK", "MANCHESTER", "ROTHERHAM", "BRADFORD"];
const NUM_CITIES = CITY_NAMES.length;
const LAUNCHER_POS = [100, 250, 400, 550, 700];
const MISSILES_PER_CITY = 50;
let cities = [];
let missiles = [];
let enemyMissiles = [];
let bombs = [];
let explosions = [];
let score = 0;
let gameOver = false;
let level = 1;
let missilesThisLevel = 0;
let missilesLaunched = 0;
let missileBaseSpeed = 0.55;
let levelingUp = false;
let clouds = [];
const NUM_CLOUDS = 5;

// Sound
const sndLaunch = document.getElementById('sndLaunch');
const sndExplosion = document.getElementById('sndExplosion');
const sndLose = document.getElementById('sndLose');

// Procedural sound functions using Web Audio API
function playLaunchSound() {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = 'sawtooth';
    o.frequency.setValueAtTime(220, ctx.currentTime);
    o.frequency.linearRampToValueAtTime(660, ctx.currentTime + 0.15);
    g.gain.setValueAtTime(0.2, ctx.currentTime);
    g.gain.linearRampToValueAtTime(0.01, ctx.currentTime + 0.15);
    o.connect(g).connect(ctx.destination);
    o.start();
    o.stop(ctx.currentTime + 0.15);
    o.onended = () => ctx.close();
}

function playExplosionSound() {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const bufferSize = 4096;
    const noise = ctx.createBufferSource();
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const output = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        output[i] = Math.random() * 2 - 1;
    }
    noise.buffer = buffer;
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.5, ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4);
    noise.connect(g).connect(ctx.destination);
    noise.start();
    noise.stop(ctx.currentTime + 0.4);
    noise.onended = () => ctx.close();
}

function playLoseSound() {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = 'square';
    o.frequency.setValueAtTime(220, ctx.currentTime);
    o.frequency.linearRampToValueAtTime(110, ctx.currentTime + 0.6);
    g.gain.setValueAtTime(0.3, ctx.currentTime);
    g.gain.linearRampToValueAtTime(0.01, ctx.currentTime + 0.6);
    o.connect(g).connect(ctx.destination);
    o.start();
    o.stop(ctx.currentTime + 0.6);
    o.onended = () => ctx.close();
}

// City positions (with missile count)
for (let i = 0; i < NUM_CITIES; i++) {
    cities.push({
        name: CITY_NAMES[i],
        x: LAUNCHER_POS[i],
        alive: true,
        missiles: MISSILES_PER_CITY
    });
}

// Factory/cityscape drawing BETWEEN cities
function drawCityBackground() {
    ctx.save();
    // Draw factory elements BETWEEN cities
    for (let i = 0; i < cities.length - 1; i++) {
        let x = (cities[i].x + cities[i+1].x) / 2;
        // Big smokestack
        ctx.fillStyle = "#444";
        ctx.fillRect(x - 10, h - 130, 18, 80);
        // Big factory block
        ctx.fillStyle = "#222";
        ctx.fillRect(x - 32, h - 70, 60, 35);
        // Warehouse front
        ctx.fillStyle = "#555";
        ctx.fillRect(x - 22, h - 40, 44, 20);
        // Windows/lights
        ctx.fillStyle = "#ffd700";
        for (let k = 0; k < 5; k++) {
            ctx.fillRect(x - 28 + k * 12, h - 60, 6, 10);
        }
        // Chimney smoke (cartoon)
        ctx.beginPath();
        ctx.arc(x, h - 140, 10, 0, 2 * Math.PI);
        ctx.fillStyle = "rgba(200,200,200,0.22)";
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x + 7, h - 152, 7, 0, 2 * Math.PI);
        ctx.fillStyle = "rgba(210,210,210,0.14)";
        ctx.fill();
    }
    ctx.restore();
}

function drawTitle() {
    ctx.save();
    ctx.font = "40px 'Press Start 2P', monospace";
    ctx.fillStyle = "#0ff";
    ctx.textAlign = "center";
    ctx.fillText("ANAL COMMAND", w / 2, 90);
    ctx.font = "22px 'Press Start 2P', monospace";
    ctx.fillStyle = "#ff0";
    ctx.fillText(`LEVEL ${level}`, w / 2, 130);
    ctx.restore();
}

function drawCities() {
    ctx.save();
    ctx.font = "18px 'Press Start 2P', monospace";
    for (let i = 0; i < cities.length; i++) {
        if (cities[i].alive) {
            // City block
            ctx.fillStyle = "#0cf";
            ctx.fillRect(cities[i].x - 25, h - 70, 50, 40);
            // Launcher
            ctx.fillStyle = "#fa3";
            ctx.beginPath();
            ctx.arc(cities[i].x, h - 75, 12, Math.PI, 0);
            ctx.fill();
        }
        // City name
        ctx.font = "18px 'Press Start 2P', monospace";
        ctx.fillStyle = "#ff0";
        ctx.textAlign = "center";
        ctx.fillText(cities[i].name, cities[i].x, h - 15);

        // Missile number (UNDER city)
        ctx.font = "18px 'Press Start 2P', monospace";
        ctx.fillStyle = cities[i].alive
          ? (cities[i].missiles > 0 ? "#0cf" : "#f33")
          : "#222";
        ctx.fillText("â–² " + cities[i].missiles, cities[i].x, h - 5);
    }
    ctx.restore();
}

function drawMissiles() {
    // Player missiles
    ctx.strokeStyle = "#0f0";
    ctx.lineWidth = 2;
    for (const m of missiles) {
        ctx.beginPath();
        ctx.moveTo(m.x0, m.y0);
        ctx.lineTo(m.x, m.y);
        ctx.stroke();
    }
    // Enemy missiles
    ctx.strokeStyle = "#f00";
    for (const em of enemyMissiles) {
        ctx.beginPath();
        ctx.moveTo(em.x0, em.y0);
        ctx.lineTo(em.x, em.y);
        ctx.stroke();
    }
    // Bombs are drawn separately
}

function drawBombs() {
    for (const b of bombs) {
        // Parachute
        ctx.save();
        ctx.beginPath();
        ctx.arc(b.x, b.y + 8, 16, Math.PI, 2 * Math.PI);
        ctx.fillStyle = '#fff';
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(b.x - 16, b.y + 8);
        ctx.lineTo(b.x - 4, b.y + 20);
        ctx.moveTo(b.x + 16, b.y + 8);
        ctx.lineTo(b.x + 4, b.y + 20);
        ctx.strokeStyle = '#aaa';
        ctx.lineWidth = 2;
        ctx.stroke();
        // Bomb body
        ctx.beginPath();
        ctx.ellipse(b.x, b.y + 24, 7, 12, 0, 0, 2 * Math.PI);
        ctx.fillStyle = '#ff0';
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.stroke();
        ctx.restore();
    }
}

function drawExplosions() {
    for (const e of explosions) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r, 0, 2 * Math.PI);
        ctx.fillStyle = "rgba(255,255,255,0.4)";
        ctx.fill();
        ctx.restore();
    }
}

function drawGameOver() {
    ctx.save();
    ctx.font = "48px 'Press Start 2P', monospace";
    ctx.fillStyle = "#f00";
    ctx.textAlign = "center";
    ctx.fillText("GAME OVER", w / 2, h / 2);
    ctx.font = "32px 'Press Start 2P', monospace";
    ctx.fillStyle = "#ff0";
    ctx.fillText("Score: " + score, w / 2, h / 2 + 60);
    ctx.font = "28px 'Press Start 2P', monospace";
    ctx.fillStyle = "#0ff";
    ctx.fillText(`Level: ${level}`, w / 2, h / 2 + 110);
    ctx.restore();
}

// Missile logic
function spawnEnemyMissile() {
    let aliveCities = cities.filter(c => c.alive);
    if (aliveCities.length === 0) return;
    if (missilesLaunched >= missilesThisLevel) return;
    let target = aliveCities[Math.floor(Math.random() * aliveCities.length)];
    let x0 = Math.random() * w;
    let y0 = 0;
    let x1 = target.x;
    let y1 = h - 70;
    let speed = missileBaseSpeed + (level - 1) * 0.06 + Math.random() * 0.35;
    enemyMissiles.push({ x0, y0, x: x0, y: y0, x1, y1, speed });
    missilesLaunched++;
}

function spawnPlayerMissile(targetX, targetY) {
    // Find closest alive launcher with ammo
    let minDist = Infinity, idx = -1;
    for (let i = 0; i < cities.length; i++) {
        if (cities[i].alive && cities[i].missiles > 0) {
            let d = Math.abs(cities[i].x - targetX);
            if (d < minDist) {
                minDist = d;
                idx = i;
            }
        }
    }
    if (idx === -1) return; // No city with ammo
    let x0 = cities[idx].x;
    let y0 = h - 75;
    let speed = 5;
    missiles.push({ x0, y0, x: x0, y: y0, x1: targetX, y1: targetY, speed });
    cities[idx].missiles--;
    playLaunchSound();
}

function spawnBomb() {
    let aliveCities = cities.filter(c => c.alive);
    if (aliveCities.length === 0) return;
    let target = aliveCities[Math.floor(Math.random() * aliveCities.length)];
    let x = target.x + (Math.random() - 0.5) * 60;
    let y = 0;
    let speed = 0.6 + Math.random() * 0.3; // Slow fall
    bombs.push({ x, y, targetX: target.x, speed, landed: false });
}

function updateMissiles() {
    // Player missiles
    for (let i = missiles.length - 1; i >= 0; i--) {
        let m = missiles[i];
        let dx = m.x1 - m.x, dy = m.y1 - m.y;
        let dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < m.speed) {
            // Explode
            explosions.push({ x: m.x1, y: m.y1, r: 1, maxR: 50, frame: 0 });
            playExplosionSound();
            missiles.splice(i, 1);
            continue;
        }
        m.x += m.speed * dx / dist;
        m.y += m.speed * dy / dist;
    }
    // Enemy missiles
    for (let i = enemyMissiles.length - 1; i >= 0; i--) {
        let em = enemyMissiles[i];
        let dx = em.x1 - em.x, dy = em.y1 - em.y;
        let dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < em.speed) {
            // Hit!
            for (let city of cities) {
                if (city.alive && Math.abs(city.x - em.x1) < 28) {
                    city.alive = false;
                    playExplosionSound();
                    break;
                }
            }
            enemyMissiles.splice(i, 1);
            continue;
        }
        // Check for explosion collision
        for (let e of explosions) {
            let d = Math.sqrt((em.x - e.x) ** 2 + (em.y - e.y) ** 2);
            if (d < e.r) {
                score += 100;
                playExplosionSound();
                enemyMissiles.splice(i, 1);
                break;
            }
        }
        em.x += em.speed * dx / dist;
        em.y += em.speed * dy / dist;
    }
    // Bombs
    for (let i = bombs.length - 1; i >= 0; i--) {
        let b = bombs[i];
        if (b.landed) continue;
        b.y += b.speed;
        // Check for explosion collision
        let exploded = false;
        for (let e of explosions) {
            let d = Math.sqrt((b.x - e.x) ** 2 + (b.y + 24 - e.y) ** 2);
            if (d < e.r) {
                score += 200;
                playExplosionSound();
                bombs.splice(i, 1);
                exploded = true;
                break;
            }
        }
        if (exploded) continue;
        // Check if bomb lands on a city
        for (let city of cities) {
            if (city.alive && Math.abs(city.x - b.x) < 28 && b.y + 24 >= h - 70) {
                city.alive = false;
                playExplosionSound();
                bombs.splice(i, 1);
                break;
            }
        }
        // Remove if off screen
        if (b.y > h + 40) bombs.splice(i, 1);
    }
}

function updateExplosions() {
    for (let i = explosions.length - 1; i >= 0; i--) {
        let e = explosions[i];
        e.frame++;
        if (e.frame < 10) {
            e.r += 5;
        } else if (e.frame < 20) {
            e.r += 2;
        } else {
            e.r -= 4;
            if (e.r < 0) {
                explosions.splice(i, 1);
            }
        }
    }
}

function startLevel(lv) {
    level = lv;
    if (level === 1) missilesThisLevel = 20;
    else if (level === 2) missilesThisLevel = 35;
    else if (level === 3) missilesThisLevel = 50;
    else missilesThisLevel = 50 + (level - 3) * 15;
    missilesLaunched = 0;
}

function randomCloudShape(cx, cy, scale) {
    // Generate an irregular cloud shape as an array of points
    let points = [];
    let n = 7 + Math.floor(Math.random() * 4); // 7-10 points
    let baseR = 28 * scale + Math.random() * 10 * scale;
    for (let i = 0; i < n; i++) {
        let angle = (i / n) * 2 * Math.PI;
        let r = baseR + Math.random() * 12 * scale;
        let x = cx + Math.cos(angle) * r;
        let y = cy + Math.sin(angle) * (r * (0.6 + Math.random() * 0.3));
        points.push({x, y});
    }
    return points;
}

function spawnCloud() {
    let y = 60 + Math.random() * 120;
    let scale = 0.8 + Math.random() * 0.7;
    let speed = 0.12 + Math.random() * 0.08;
    let x = Math.random() < 0.5 ? -80 : w + 80;
    let dir = x < 0 ? 1 : -1;
    let shape = randomCloudShape(0, 0, scale);
    return { x, y, speed, dir, shape, scale, alpha: 0.7 + Math.random() * 0.2 };
}

for (let i = 0; i < NUM_CLOUDS; i++) {
    clouds.push(spawnCloud());
}

function updateClouds() {
    for (let c of clouds) {
        c.x += c.speed * c.dir;
    }
    // Respawn clouds that go off screen
    for (let i = 0; i < clouds.length; i++) {
        if ((clouds[i].dir === 1 && clouds[i].x > w + 100) || (clouds[i].dir === -1 && clouds[i].x < -100)) {
            clouds[i] = spawnCloud();
            clouds[i].dir = Math.random() < 0.5 ? 1 : -1;
            clouds[i].x = clouds[i].dir === 1 ? -80 : w + 80;
        }
    }
}

function drawClouds() {
    ctx.save();
    for (let c of clouds) {
        ctx.globalAlpha = c.alpha;
        ctx.beginPath();
        let first = true;
        for (let pt of c.shape) {
            let px = c.x + pt.x;
            let py = c.y + pt.y;
            if (first) {
                ctx.moveTo(px, py);
                first = false;
            } else {
                ctx.lineTo(px, py);
            }
        }
        ctx.closePath();
        ctx.fillStyle = '#fff';
        ctx.shadowColor = '#ddeeff';
        ctx.shadowBlur = 16;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1.0;
    }
    ctx.restore();
}

// Main loop
function gameLoop() {
    ctx.clearRect(0, 0, w, h);
    document.getElementById("score").innerHTML = `Score: ${score} | Level: ${level}`;
    drawCityBackground();
    drawTitle();
    updateClouds();
    drawClouds();
    drawCities();
    drawMissiles();
    drawBombs();
    drawExplosions();
    if (gameOver) {
        drawGameOver();
        return;
    }
    updateMissiles();
    updateExplosions();

    // Lose check
    if (!cities.some(c => c.alive)) {
        if (!gameOver) playLoseSound();
        gameOver = true;
    }

    // Level up check: all missiles for this level launched and none left on screen
    if (!gameOver && !levelingUp && missilesLaunched >= missilesThisLevel && enemyMissiles.length === 0) {
        levelingUp = true;
        setTimeout(() => {
            startLevel(level + 1);
            levelingUp = false;
        }, 1200);
    }

    requestAnimationFrame(gameLoop);
}

// Missile spawn interval
let missileInterval = setInterval(() => {
    if (!gameOver) spawnEnemyMissile();
}, 1600); // slower spawn

// Bomb spawn interval
let lastBombTime = 0;
const bombCooldown = 25000; // 25 seconds

function trySpawnBomb() {
    const now = Date.now();
    if (!gameOver && now - lastBombTime > bombCooldown) {
        spawnBomb();
        lastBombTime = now;
    }
}

setInterval(trySpawnBomb, 1000);

canvas.addEventListener('click', function(e) {
    if (gameOver) return;
    let rect = canvas.getBoundingClientRect();
    let x = e.clientX - rect.left;
    let y = e.clientY - rect.top;
    if (y < h - 120) spawnPlayerMissile(x, y);
});

canvas.addEventListener('contextmenu', function(e) {
    e.preventDefault();
    if (!gameOver) return;
    // Reset game
    cities = [];
    for (let i = 0; i < NUM_CITIES; i++) {
        cities.push({
            name: CITY_NAMES[i],
            x: LAUNCHER_POS[i],
            alive: true,
            missiles: MISSILES_PER_CITY
        });
    }
    missiles = [];
    enemyMissiles = [];
    bombs = [];
    explosions = [];
    score = 0;
    gameOver = false;
    lastBombTime = 0;
    levelingUp = false;
    startLevel(1);
    gameLoop();
});

startLevel(1);
gameLoop();
</script>
</body>
</html>
