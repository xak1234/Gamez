
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Anal Command</title>
    <style>
        body {
            background: #000;
            color: #0ff;
            font-family: 'Press Start 2P', monospace, sans-serif;
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
            margin: 0 auto;
            background: #000;
        }
        #score {
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 30px;
            color: #0090ff;
            letter-spacing: 3px;
            font-family: 'Press Start 2P', monospace, sans-serif;
            text-shadow: 1px 1px #111, 0 0 8px #22f;
        }
    </style>
</head>
<body>
<div id="score"></div>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<audio id="sndLaunch" src="https://cdn.pixabay.com/audio/2022/07/26/audio_12ccefa48c.mp3" preload="auto"></audio>
<audio id="sndExplosion" src="https://cdn.pixabay.com/audio/2022/07/26/audio_123ef6f88d.mp3" preload="auto"></audio>
<audio id="sndLose" src="https://cdn.pixabay.com/audio/2022/07/26/audio_124b6a3a44.mp3" preload="auto"></audio>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const w = canvas.width, h = canvas.height;

const CITY_NAMES = ["LEEDS", "YORK", "MANCHESTER", "ROTHERHAM", "BRADFORD"];
const NUM_CITIES = CITY_NAMES.length;
const LAUNCHER_POS = [100, 250, 400, 550, 700];
const MISSILES_PER_CITY = 50;
let cities = [];
let missiles = [];
let enemyMissiles = [];
let bombs = [];
let explosions = [];
let clouds = [];
let score = 0;
let gameOver = false;

// Sound
const sndLaunch = document.getElementById('sndLaunch');
const sndExplosion = document.getElementById('sndExplosion');
const sndLose = document.getElementById('sndLose');

// Procedural sound functions using Web Audio API
function playLaunchSound() {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = 'sawtooth';
    o.frequency.setValueAtTime(220, ctx.currentTime);
    o.frequency.linearRampToValueAtTime(660, ctx.currentTime + 0.15);
    g.gain.setValueAtTime(0.2, ctx.currentTime);
    g.gain.linearRampToValueAtTime(0.01, ctx.currentTime + 0.15);
    o.connect(g).connect(ctx.destination);
    o.start();
    o.stop(ctx.currentTime + 0.15);
    o.onended = () => ctx.close();
}

function playExplosionSound() {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const bufferSize = 4096;
    const noise = ctx.createBufferSource();
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const output = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        output[i] = Math.random() * 2 - 1;
    }
    noise.buffer = buffer;
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.5, ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4);
    noise.connect(g).connect(ctx.destination);
    noise.start();
    noise.stop(ctx.currentTime + 0.4);
    noise.onended = () => ctx.close();
}

function playLoseSound() {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = 'square';
    o.frequency.setValueAtTime(220, ctx.currentTime);
    o.frequency.linearRampToValueAtTime(110, ctx.currentTime + 0.6);
    g.gain.setValueAtTime(0.3, ctx.currentTime);
    g.gain.linearRampToValueAtTime(0.01, ctx.currentTime + 0.6);
    o.connect(g).connect(ctx.destination);
    o.start();
    o.stop(ctx.currentTime + 0.6);
    o.onended = () => ctx.close();
}

// City positions (with missile count)
for (let i = 0; i < NUM_CITIES; i++) {
    cities.push({
        name: CITY_NAMES[i],
        x: LAUNCHER_POS[i],
        alive: true,
        missiles: MISSILES_PER_CITY
    });
}

// Initialize clouds
function initClouds() {
    clouds = [];
    for (let i = 0; i < 6; i++) {
        clouds.push({
            x: Math.random() * w,
            y: 40 + Math.random() * 120,
            speed: 0.2 + Math.random() * 0.15,
            size: 40 + Math.random() * 40,
            pattern: Array.from({length: 4 + Math.floor(Math.random() * 3)}, () => ({
                dx: (Math.random() - 0.5) * 1.2,
                dy: (Math.random() - 0.5) * 1.2,
                rx: 0.3 + Math.random() * 0.7,
                ry: 0.18 + Math.random() * 0.32
            }))
        });
    }
}

function updateClouds() {
    for (let c of clouds) {
        c.x += c.speed;
        if (c.x - c.size > w) {
            c.x = -c.size;
            c.y = 40 + Math.random() * 120;
            c.speed = 0.2 + Math.random() * 0.15;
            c.size = 40 + Math.random() * 40;
            c.pattern = Array.from({length: 4 + Math.floor(Math.random() * 3)}, () => ({
                dx: (Math.random() - 0.5) * 1.2,
                dy: (Math.random() - 0.5) * 1.2,
                rx: 0.3 + Math.random() * 0.7,
                ry: 0.18 + Math.random() * 0.32
            }));
        }
    }
}

function drawClouds() {
    ctx.save();
    for (let c of clouds) {
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        for (let p of c.pattern) {
            ctx.ellipse(
                c.x + p.dx * c.size,
                c.y + p.dy * c.size,
                c.size * p.rx,
                c.size * p.ry,
                0, 0, 2 * Math.PI
            );
        }
        ctx.fill();
    }
    ctx.globalAlpha = 1.0;
    ctx.restore();
}

// Factory/cityscape drawing BETWEEN cities
function drawCityBackground() {
    ctx.save();
    // Draw factory elements BETWEEN cities
    for (let i = 0; i < cities.length - 1; i++) {
        let x = (cities[i].x + cities[i+1].x) / 2;
        // Big smokestack
        ctx.fillStyle = "#444";
        ctx.fillRect(x - 10, h - 130, 18, 80);
        // Big factory block
        ctx.fillStyle = "#222";
        ctx.fillRect(x - 32, h - 70, 60, 35);
        // Warehouse front
        ctx.fillStyle = "#555";
        ctx.fillRect(x - 22, h - 40, 44, 20);
        // Windows/lights
        ctx.fillStyle = "#ffd700";
        for (let k = 0; k < 5; k++) {
            ctx.fillRect(x - 28 + k * 12, h - 60, 6, 10);
        }
        // Chimney smoke (cartoon)
        ctx.beginPath();
        ctx.arc(x, h - 140, 10, 0, 2 * Math.PI);
        ctx.fillStyle = "rgba(200,200,200,0.22)";
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x + 7, h - 152, 7, 0, 2 * Math.PI);
        ctx.fillStyle = "rgba(210,210,210,0.14)";
        ctx.fill();
    }
    ctx.restore();
}

function drawTitle() {
    ctx.save();
    ctx.font = "64px 'Press Start 2P', monospace";
    ctx.fillStyle = "#0ff";
    ctx.textAlign = "center";
    ctx.fillText("ANAL COMMAND", w / 2, 90);
    ctx.restore();
}

function drawCities() {
    ctx.save();
    ctx.font = "13px 'Press Start 2P', monospace";
    for (let i = 0; i < cities.length; i++) {
        if (cities[i].alive) {
            // City block
            ctx.fillStyle = "#0cf";
            ctx.fillRect(cities[i].x - 25, h - 70, 50, 40);
            // Launcher
            ctx.fillStyle = "#fa3";
            ctx.beginPath();
            ctx.arc(cities[i].x, h - 75, 12, Math.PI, 0);
            ctx.fill();
        }
        // City name
        ctx.font = "13px 'Press Start 2P', monospace";
        ctx.fillStyle = "#ff0";
        ctx.textAlign = "center";
        ctx.fillText(cities[i].name, cities[i].x, h - 15);

        // Missile number (UNDER city)
        ctx.font = "13px 'Press Start 2P', monospace";
        ctx.fillStyle = cities[i].alive
          ? (cities[i].missiles > 0 ? "#0cf" : "#f33")
          : "#222";
        ctx.fillText("â–² " + cities[i].missiles, cities[i].x, h - 5);
    }
    ctx.restore();
}

function drawMissiles() {
    // Player missiles
    ctx.strokeStyle = "#0f0";
    ctx.lineWidth = 2;
    for (const m of missiles) {
        ctx.beginPath();
        ctx.moveTo(m.x0, m.y0);
        ctx.lineTo(m.x, m.y);
        ctx.stroke();
    }
    // Enemy missiles
    ctx.strokeStyle = "#f00";
    for (const em of enemyMissiles) {
        ctx.beginPath();
        ctx.moveTo(em.x0, em.y0);
        ctx.lineTo(em.x, em.y);
        ctx.stroke();
    }
    // Bombs are drawn separately
}

function drawBombs() {
    for (const b of bombs) {
        // Parachute
        ctx.save();
        ctx.beginPath();
        ctx.arc(b.x, b.y + 8, 16, Math.PI, 2 * Math.PI);
        ctx.fillStyle = '#fff';
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(b.x - 16, b.y + 8);
        ctx.lineTo(b.x - 4, b.y + 20);
        ctx.moveTo(b.x + 16, b.y + 8);
        ctx.lineTo(b.x + 4, b.y + 20);
        ctx.strokeStyle = '#aaa';
        ctx.lineWidth = 2;
        ctx.stroke();
        // Bomb body
        ctx.beginPath();
        ctx.ellipse(b.x, b.y + 24, 7, 12, 0, 0, 2 * Math.PI);
        ctx.fillStyle = '#ff0';
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.stroke();
        ctx.restore();
    }
}

function drawExplosions() {
    for (const e of explosions) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r, 0, 2 * Math.PI);
        if (e.color === 'player') {
            ctx.fillStyle = "rgba(0,180,255,0.45)";
        } else {
            ctx.fillStyle = "rgba(255,255,255,0.4)";
        }
        ctx.fill();
        ctx.restore();
    }
}

function drawGameOver() {
    ctx.save();
    ctx.font = "48px 'Press Start 2P', monospace";
    ctx.fillStyle = "#f00";
    ctx.textAlign = "center";
    ctx.fillText("GAME OVER", w / 2, h / 2);
    ctx.font = "32px 'Press Start 2P', monospace";
    ctx.fillStyle = "#ff0";
    ctx.fillText("Score: " + score, w / 2, h / 2 + 60);
    ctx.restore();
}

// Missile logic
function spawnEnemyMissile() {
    let aliveCities = cities.filter(c => c.alive);
    if (aliveCities.length === 0) return;
    let target = aliveCities[Math.floor(Math.random() * aliveCities.length)];
    let x0 = Math.random() * w;
    let y0 = 0;
    let x1 = target.x;
    let y1 = h - 70;
    let speed = 0.25 + Math.random() * 0.35; // MUCH SLOWER INCOMING!
    enemyMissiles.push({ x0, y0, x: x0, y: y0, x1, y1, speed });
}

function spawnPlayerMissile(targetX, targetY) {
    // Find closest alive launcher with ammo
    let minDist = Infinity, idx = -1;
    for (let i = 0; i < cities.length; i++) {
        if (cities[i].alive && cities[i].missiles > 0) {
            let d = Math.abs(cities[i].x - targetX);
            if (d < minDist) {
                minDist = d;
                idx = i;
            }
        }
    }
    if (idx === -1) return; // No city with ammo
    let x0 = cities[idx].x;
    let y0 = h - 75;
    let speed = 5;
    missiles.push({ x0, y0, x: x0, y: y0, x1: targetX, y1: targetY, speed });
    cities[idx].missiles--;
    playLaunchSound();
}

function spawnBomb() {
    let aliveCities = cities.filter(c => c.alive);
    if (aliveCities.length === 0) return;
    let target = aliveCities[Math.floor(Math.random() * aliveCities.length)];
    let x = target.x + (Math.random() - 0.5) * 60;
    let y = 0;
    let speed = 0.6 + Math.random() * 0.3; // Slow fall
    bombs.push({ x, y, targetX: target.x, speed, landed: false });
}

function updateMissiles() {
    // Player missiles
    for (let i = missiles.length - 1; i >= 0; i--) {
        let m = missiles[i];
        let dx = m.x1 - m.x, dy = m.y1 - m.y;
        let dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < m.speed) {
            // Explode
            explosions.push({ x: m.x1, y: m.y1, r: 1, maxR: 50, frame: 0, color: 'player' });
            playExplosionSound();
            missiles.splice(i, 1);
            continue;
        }
        m.x += m.speed * dx / dist;
        m.y += m.speed * dy / dist;
    }
    // Enemy missiles
    for (let i = enemyMissiles.length - 1; i >= 0; i--) {
        let em = enemyMissiles[i];
        let dx = em.x1 - em.x, dy = em.y1 - em.y;
        let dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < em.speed) {
            // Hit!
            for (let city of cities) {
                if (city.alive && Math.abs(city.x - em.x1) < 28) {
                    city.alive = false;
                    playExplosionSound();
                    break;
                }
            }
            enemyMissiles.splice(i, 1);
            continue;
        }
        // Check for explosion collision
        for (let e of explosions) {
            let d = Math.sqrt((em.x - e.x) ** 2 + (em.y - e.y) ** 2);
            if (d < e.r) {
                score += 100;
                playExplosionSound();
                enemyMissiles.splice(i, 1);
                break;
            }
        }
        em.x += em.speed * dx / dist;
        em.y += em.speed * dy / dist;
    }
    // Bombs
    for (let i = bombs.length - 1; i >= 0; i--) {
        let b = bombs[i];
        if (b.landed) continue;
        b.y += b.speed;
        // Check for explosion collision
        let exploded = false;
        for (let e of explosions) {
            let d = Math.sqrt((b.x - e.x) ** 2 + (b.y + 24 - e.y) ** 2);
            if (d < e.r) {
                score += 200;
                playExplosionSound();
                bombs.splice(i, 1);
                exploded = true;
                break;
            }
        }
        if (exploded) continue;
        // Check if bomb lands on a city
        for (let city of cities) {
            if (city.alive && Math.abs(city.x - b.x) < 28 && b.y + 24 >= h - 70) {
                city.alive = false;
                playExplosionSound();
                bombs.splice(i, 1);
                break;
            }
        }
        // Remove if off screen
        if (b.y > h + 40) bombs.splice(i, 1);
    }
}

function updateExplosions() {
    for (let i = explosions.length - 1; i >= 0; i--) {
        let e = explosions[i];
        e.frame++;
        if (e.frame < 10) {
            e.r += 5;
        } else if (e.frame < 20) {
            e.r += 2;
        } else {
            e.r -= 4;
            if (e.r < 0) {
                explosions.splice(i, 1);
            }
        }
    }
}

// Main loop
function gameLoop() {
    ctx.clearRect(0, 0, w, h);
    updateClouds();
    // Show score and level at the top
    ctx.save();
    ctx.font = "18px 'Press Start 2P', monospace";
    ctx.fillStyle = "#0090ff";
    ctx.textAlign = "left";
    ctx.fillText(`Score: ${score}`, 18, 32);
    ctx.textAlign = "right";
    ctx.fillStyle = "#ff0";
    ctx.fillText(`Level: ${typeof level !== 'undefined' ? level : 1}`, w - 18, 32);
    ctx.restore();
    drawCityBackground();
    drawTitle();
    drawCities();
    drawMissiles();
    drawClouds();
    drawBombs();
    drawExplosions();
    if (gameOver) {
        drawGameOver();
        return;
    }
    updateMissiles();
    updateExplosions();

    // Lose check
    if (!cities.some(c => c.alive)) {
        if (!gameOver) playLoseSound();
        gameOver = true;
    }

    requestAnimationFrame(gameLoop);
}

// Missile spawn interval
let missileInterval = setInterval(() => {
    if (!gameOver) spawnEnemyMissile();
}, 1600); // slower spawn

// Bomb spawn interval
let lastBombTime = 0;
const bombCooldown = 25000; // 25 seconds

function trySpawnBomb() {
    const now = Date.now();
    if (!gameOver && now - lastBombTime > bombCooldown) {
        spawnBomb();
        lastBombTime = now;
    }
}

setInterval(trySpawnBomb, 1000);

canvas.addEventListener('click', function(e) {
    if (gameOver) return;
    let rect = canvas.getBoundingClientRect();
    let x = e.clientX - rect.left;
    let y = e.clientY - rect.top;
    if (y < h - 120) spawnPlayerMissile(x, y);
});

canvas.addEventListener('contextmenu', function(e) {
    e.preventDefault();
    if (!gameOver) return;
    // Reset game
    cities = [];
    for (let i = 0; i < NUM_CITIES; i++) {
        cities.push({
            name: CITY_NAMES[i],
            x: LAUNCHER_POS[i],
            alive: true,
            missiles: MISSILES_PER_CITY
        });
    }
    missiles = [];
    enemyMissiles = [];
    bombs = [];
    explosions = [];
    score = 0;
    gameOver = false;
    lastBombTime = 0;
    initClouds();
    gameLoop();
});

// After initializing cities, add:
initClouds();

gameLoop();
</script>
</body>
</html>
