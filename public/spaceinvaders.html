<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Invaders - High Scores!</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body, html { width: 100%; height: 100%; margin: 0; padding: 0; background-color: #000; color: #fff; display: flex; flex-direction: column; align-items: center; justify-content: center; font-family: 'Press Start 2P', cursive; overflow: hidden; }
        canvas {
            display: block;
            background-color: #000;
            box-shadow: 0 0 10px 5px #0f0, 0 0 15px 10px #0f0 inset;
            border: 2px solid #0f0;
            border-radius: 8px;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            max-width: 100%;
            max-height: 75vh; /* Adjusted for more info */
            aspect-ratio: 4 / 3;
            touch-action: none; /* ADDED THIS LINE to prevent default touch actions on the canvas */
        }
        #gameInfo { display: flex; flex-wrap: wrap; justify-content: center; width: 100%; max-width: 700px; /* Wider for more items */ margin-bottom: 10px; font-size: 0.9rem; /* Slightly smaller base for more items */ color: #0f0; text-align: center;}
        #gameInfo > div { margin: 2px 6px; }
        #highScoreDisplay { color: #fff; } /* HIGHSCORE: Style for high score display */
        #laserTimeBoard { color: #ff9900; visibility: hidden; }
        #fireRateBoostIndicator { color: #00ffff; visibility: hidden; font-size: 0.9em;}
        #doubleShotIndicator { color: #f0f; visibility: hidden; font-size: 0.9em;}
        #scoreMultiplierIndicator { color: #ffff00; visibility: hidden; font-size: 0.9em;}
        #waveDisplay { color: #7f7fff; font-size: 1.0em; } /* Adjusted wave display size slightly */

        #messageBox { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.85); color: #fff; padding: 30px; border: 3px solid #0f0; border-radius: 10px; text-align: center; z-index: 100; box-shadow: 0 0 15px #0f0; display: none; }
        #messageBox h1 { font-size: 2rem; color: #0f0; margin-bottom: 15px; }
        #messageBox p { font-size: 1rem; margin-bottom: 20px; }
        #messageBox button { background-color: #0f0; color: #000; border: none; padding: 12px 25px; font-family: 'Press Start 2P', cursive; font-size: 1rem; cursor: pointer; border-radius: 5px; transition: background-color 0.2s, transform 0.2s; }
        #messageBox button:hover { background-color: #3f3; transform: scale(1.05); }
        #touchControls { display: none; margin-top: 10px; width: 100%; max-width: 400px; justify-content: space-between; }
        #touchControls button { font-size: 1.5rem; padding: 15px 20px; width: 30%; flex-grow: 1; margin: 0 5px; }
        #touchControls button:first-child { margin-left: 0; } #touchControls button:last-child { margin-right: 0; }
        
        .shake { animation: shake 0.15s cubic-bezier(.36,.07,.19,.97) both; transform: translate3d(0, 0, 0); backface-visibility: hidden; perspective: 1000px; }
        @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-3px, 0, 0); } 40%, 60% { transform: translate3d(3px, 0, 0); } }

        #downloadHighScoreButton { 
            background-color: #333; color: #0f0; border: 1px solid #0f0; padding: 5px 10px;
            font-family: 'Press Start 2P', cursive; font-size: 0.7rem; cursor: pointer;
            border-radius: 3px; margin-top: 5px; display: block; margin-left: auto; margin-right: auto;
        }
        #downloadHighScoreButton:hover { background-color: #444; }

        /* Style for the alien taunt box */
        #alienTauntBox {
            position: absolute;
            top: 10px; /* Position above the canvas */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: #0f0;
            padding: 8px 15px;
            border: 1px solid #0f0;
            border-radius: 5px;
            font-size: 0.8rem;
            text-align: center;
            z-index: 99;
            display: none; /* Hidden by default */
            max-width: 80%; /* Ensure it fits on smaller screens */
            box-shadow: 0 0 8px #0f0;
        }


        @media (max-width: 600px) { #touchControls { display: flex; } #gameInfo { font-size: 0.7rem; } #gameInfo > div { margin-bottom: 2px; } #messageBox h1 { font-size: 1.5rem; } #messageBox p { font-size: 0.9rem; } #messageBox button { padding: 10px 20px; font-size: 0.9rem; } canvas { max-height: 70vh; } }
        @media (max-height: 450px) and (orientation: landscape) { #gameInfo { flex-direction: row; font-size: 0.6rem; } canvas { max-height: 65vh; } #touchControls { margin-top: 10px; } #touchControls button { font-size: 1.2rem; padding: 10px 15px; } #messageBox { padding: 15px; } #messageBox h1 { font-size: 1.2rem; } #messageBox p { font-size: 0.8rem; } #messageBox button { padding: 8px 12px; font-size: 0.8rem; } }
    </style>
</head>
<body>
    <div id="gameInfo">
        <div id="scoreBoard">Score: 0</div>
        <div id="highScoreDisplay">High Score: 0</div> 
        <div id="livesBoard">Lives: 3</div>
        <div id="waveDisplay">Wave: 1</div>
        <div id="laserTimeBoard">Laser Time: 0s</div>
        <div id="fireRateBoostIndicator">Fire Rate Up!</div>
        <div id="doubleShotIndicator">Double Shot!</div>
        <div id="scoreMultiplierIndicator">2x Score!</div>
        <div id="torpedoIndicator">Torpedo: 0s</div>
        <div id="nuclearIndicator">Nuclear: 0s</div>
    </div>
    <button id="downloadHighScoreButton">Download Highscore File</button> 
    <canvas id="gameCanvas"></canvas>
    <div id="messageBox"><h1 id="messageTitle"></h1><p id="messageText"></p><button id="messageButton"></button></div>
    <div id="touchControls"><button id="touchLeft">‚¨ÖÔ∏è</button><button id="touchFire">üî•</button><button id="touchRight">‚û°Ô∏è</button></div>
    <div id="alienTauntBox"></div> <script>
        // DOM Elements
        const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
        const scoreBoard = document.getElementById('scoreBoard'), livesBoard = document.getElementById('livesBoard');
        const highScoreDisplay = document.getElementById('highScoreDisplay'); // HIGHSCORE
        const laserTimeBoard = document.getElementById('laserTimeBoard');
        const fireRateBoostIndicator = document.getElementById('fireRateBoostIndicator'); 
        const doubleShotIndicator = document.getElementById('doubleShotIndicator'); 
        const scoreMultiplierIndicator = document.getElementById('scoreMultiplierIndicator'); 
        const waveDisplay = document.getElementById('waveDisplay'); 
        const finalScoreDisplay = document.getElementById('finalScore'); 
        const messageBox = document.getElementById('messageBox'), messageTitle = document.getElementById('messageTitle');
        const messageText = document.getElementById('messageText');
        let messageButton = document.getElementById('messageButton'); 
        const downloadHighScoreButton = document.getElementById('downloadHighScoreButton'); 
        const alienTauntBox = document.getElementById('alienTauntBox'); // Reference to the new taunt box

        // Game State Variables
        let player, ufo, chopper; 
        let score = 0, lives = 3, gameRunning = false;
        let alienDirection = 1, alienBaseSpeed = 0.5, alienSpeed = 0.5, alienDropDistance = 20, alienShootInterval = 1000, lastAlienShotTime = 0; 
        let baseAlienBulletSpeed = 3; 
        let currentAlienBulletSpeed = 3; 
        const speedIncreasePerKill = 0.03; 
        
        // Spawn Timers and Intervals
        let ufoSpawnTimer = 0; const ufoSpawnInterval = 10000; 
        let chopperSpawnTimer = 0; const chopperSpawnInterval = 20000; 

        // Game Object Arrays
        let invaders = [], bullets = [], alienBullets = [], barriers = [], chopperBombs = []; 
        let scoreMultipliers = []; 

        // Player Properties
        const playerWidth = 50, playerHeight = 30, playerSpeed = 5;
        const playerNormalColor = '#0f0', playerLaserColor = '#ff9900', playerDoubleLaserColor = '#00cyan'; 

        // Bullet Properties
        const bulletWidth = 5, bulletHeight = 15, bulletSpeed = 7, normalBulletColor = '#0f0';
        const maxNormalBullets = 3; const maxBoostedBullets = 4; 
        let playerFireRateBoostActive = false; let missedUfoCount = 0; 

        // Laser Power-up Properties
        let playerHasLaser = false, laserActivationTime = 0;
        const standardLaserDuration = 15000, doubleLaserDuration = 30000; 
        let currentLaserDuration = 0; 
        let isLaserBeamActive = false, laserBeamEndTime = 0;
        const laserBeamVisualDuration = 150, laserBeamWidth = 8, laserColor = '#ff9900';

        // DOUBLE SHOT EVENT: Variables
        let isRandomDoubleShotActive = false; let randomDoubleShotActivationTime = 0;
        const randomDoubleShotDuration = 15000; const randomDoubleShotChance = 0.03; 
        let lastRandomDoubleShotCheck = 0; const randomDoubleShotCheckInterval = 5000; 
        const doubleShotBulletOffsetX = 8; 

        // Alien Properties
        const alienRows = 5, alienCols = 10, alienWidth = 30, alienHeight = 20, alienPadding = 10, alienOffsetTop = 30, alienOffsetLeft = 30;
        const totalInvaders = alienRows * alienCols; 
        
        // Barrier Properties
        const barrierCount = 4, barrierBlockWidth = 70, barrierBlockHeight = 30, barrierSegmentSize = 10; 
        let barrierTopY; 

        // UFO Properties
        const ufoWidth = 45, ufoHeight = 20, baseUfoSpeed = 2, ufoColor = '#ff0000', ufoPoints = 100; 
        let ufoHasBanner = false;
        const ufoBannerText = 'Nicola Mudstains!';
        const ufoBannerFont = 'bold 16px "Press Start 2P", monospace';
        const ufoBannerColor = '#fff';
        const ufoBannerBg = 'rgba(0,0,0,0.7)';

        // Chopper Properties
        const chopperWidth = 60, chopperHeight = 25, chopperSpeed = 2.5, chopperColor = '#c0c0c0', chopperPoints = 150;
        const chopperAltitude = 50; const chopperBombDropInterval = 2000; 
        let lastChopperBombDropTime = 0;
        const bombWidth = 6, bombHeight = 12, bombSpeed = 4, bombColor = '#ffcc00';

        // Input State
        const keys = { ArrowLeft: false, ArrowRight: false, Space: false };

        // Audio Variables
        let synth, laserSynth, noiseSynth, ufoSynth, invaderMoveSynth, chopperSynth, bombDropSynth, powerUpSound, scoreMultiplierSound; 
        let invaderMoveSequence; 
        let audioInitialized = false;
        const baseInvaderBPM = 60; const maxInvaderBPM = 240;

        // WAVE SYSTEM: Current wave
        let currentWave = 1;

        // SCORE MULTIPLIER: Variables
        let isScoreMultiplierActive = false;
        let scoreMultiplierActivationTime = 0;
        const scoreMultiplierDuration = 15000; 
        const scoreMultiplierValue = 2;
        let lastScoreMultiplierSpawnCheck = 0;
        const scoreMultiplierSpawnInterval = 25000; 
        const scoreMultiplierSpawnChance = 0.2; 
        const scoreMultiplierSize = 15;
        const scoreMultiplierColor = '#ffff00'; 
        const scoreMultiplierDespawnTime = 8000; 

        // HIGHSCORE: Variables
        let highScore = 0;
        let deviceId = '';

        // Torpedo and Nuclear Weapon Properties
        let torpedoAvailable = false, torpedoCooldown = 2000, lastTorpedoTime = 0;
        let nuclearAvailable = false, nuclearCooldown = 15000, lastNuclearTime = 0, nuclearReady = false;
        const torpedoColor = '#00f';
        const torpedoWidth = 7, torpedoHeight = 22, torpedoSpeed = 12;
        const nuclearColor = '#fff';

        // Heart (extra life) power-up variables
        let heart = null;
        let lastHeartDropTime = 0;
        const heartDropInterval = 25000; // minimum ms between heart drops
        const heartDropChance = 0.18; // chance to drop a heart each interval
        const heartWidth = 28, heartHeight = 24;
        const heartColor = '#ff3366';

        // Large bomb (armada destroyer) variables
        let bigBomb = null;
        let lastBigBombDropTime = 0;
        const bigBombDropInterval = 20000; // ms
        const bigBombWidth = 40, bigBombHeight = 50;
        const bigBombColor = '#ff0';
        let bigBombExplosion = false;
        let bigBombExplosionTime = 0;
        const bigBombExplosionDuration = 900; // ms

        // Gemini API Taunt variables
        let lastTauntTime = 0;
        const tauntInterval = 15000; // Minimum 15 seconds between taunts
        const tauntDisplayDuration = 3000; // Taunt visible for 3 seconds
        let tauntTimeoutId = null;


        // --- HIGHSCORE FUNCTIONS ---
        function generateDeviceId() {
            if (window.crypto && window.crypto.randomUUID) {
                return window.crypto.randomUUID();
            } else {
                return 'device-' + Date.now() + '-' + Math.floor(Math.random() * 1e9);
            }
        }

        function loadHighScore() {
            const storedData = localStorage.getItem('spaceInvadersHighScoreData');
            if (storedData) {
                try {
                    const data = JSON.parse(storedData);
                    highScore = data.highScore || 0;
                    deviceId = data.deviceId || generateDeviceId(); 
                    if (!data.deviceId) { 
                        localStorage.setItem('spaceInvadersHighScoreData', JSON.stringify({ highScore, deviceId }));
                    }
                } catch (e) {
                    console.error("Error parsing high score data:", e);
                    highScore = 0;
                    deviceId = generateDeviceId();
                    localStorage.setItem('spaceInvadersHighScoreData', JSON.stringify({ highScore, deviceId }));
                }
            } else {
                highScore = 0;
                deviceId = generateDeviceId();
                localStorage.setItem('spaceInvadersHighScoreData', JSON.stringify({ highScore, deviceId }));
            }
            updateHighScoreDisplay();
        }

        function saveHighScore(newScore) {
            if (newScore > highScore) {
                highScore = newScore;
                localStorage.setItem('spaceInvadersHighScoreData', JSON.stringify({ highScore, deviceId }));
                updateHighScoreDisplay();
                console.log("New high score saved:", highScore, "by device:", deviceId);
            }
        }

        function updateHighScoreDisplay() {
            highScoreDisplay.textContent = `High Score: ${highScore}`;
        }

        function downloadHighScoreFile() {
            const data = {
                highScore: highScore,
                deviceId: deviceId,
                lastUpdated: new Date().toISOString()
            };
            const jsonString = JSON.stringify(data, null, 2); 
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'highscore.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        if(downloadHighScoreButton) downloadHighScoreButton.addEventListener('click', downloadHighScoreFile);


        // --- AUDIO INITIALIZATION ---
        async function initializeAudio() { // Made async
            if (audioInitialized) return;
            try {
                await Tone.start(); // Await Tone.start()
                synth = new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 }}).toDestination();
                laserSynth = new Tone.Synth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.05, release: 0.1 }, volume: -5 }).toDestination();
                noiseSynth = new Tone.NoiseSynth({ noise: { type: "white" }, envelope: { attack: 0.005, decay: 0.15, sustain: 0, release: 0.1 }, volume: -15 }).toDestination();
                ufoSynth = new Tone.Oscillator({ type: "sine", frequency: 880, volume: -25 }).toDestination();
                new Tone.LFO({ frequency: 2, type: "sine", min: 700, max: 1000 }).connect(ufoSynth.frequency).start();
                invaderMoveSynth = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 2, oscillator: { type: "sine" }, envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.1 }, volume: -18 }).toDestination();
                invaderMoveSequence = new Tone.Sequence((time, note) => { if(invaderMoveSynth) invaderMoveSynth.triggerAttackRelease(note, "32n", time); }, ["C2", "D#2", "F#2", "A2"], "4n");
                invaderMoveSequence.loop = true; Tone.Transport.bpm.value = baseInvaderBPM;
                chopperSynth = new Tone.NoiseSynth({ noise: { type: "brown" }, envelope: { attack: 0.05, decay: 0.1, sustain: 0.8, release: 0.2 }, volume: -25 }).toDestination();
                bombDropSynth = new Tone.Synth({ oscillator: {type: "triangle"}, envelope: {attack:0.001, decay:0.3, sustain:0, release:0.1}, pitchDecay: 0.05, volume: -10}).toDestination();
                powerUpSound = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.2 }, volume: -8 }).toDestination();
                scoreMultiplierSound = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.005, decay: 0.2, sustain: 0.1, release: 0.3 }, volume: -6 }).toDestination();
                audioInitialized = true; 
            } catch (e) { console.error("Error during audio initialization:", e); audioInitialized = false; }
        }

        // --- SOUND PLAYBACK ---
        function playSound(type, options = {}) {
            if (!audioInitialized || !Tone.context || Tone.context.state !== 'running') return;
            try {
                switch (type) {
                    case 'playerShoot': synth.triggerAttackRelease("C5", "8n"); break;
                    case 'laserShoot': laserSynth.triggerAttackRelease("A4", "16n"); break; 
                    case 'doubleLaserShoot': laserSynth.triggerAttackRelease("C5", "12n", Tone.now(), 1.2); break; 
                    case 'invaderExplosion': 
                        if (noiseSynth) { // Added safeguard
                            noiseSynth.triggerAttackRelease(0.15); 
                        } else {
                            console.warn("noiseSynth is not initialized for invaderExplosion sound.");
                        }
                        break; 
                    case 'ufoExplosion': 
                        if (noiseSynth) { // Added safeguard
                            noiseSynth.volume.value = -10; noiseSynth.triggerAttackRelease(0.3); noiseSynth.volume.value = -15; 
                        } else {
                            console.warn("noiseSynth is not initialized for ufoExplosion sound.");
                        }
                        break; 
                    case 'chopperExplosion': 
                        if (noiseSynth) { // Added safeguard
                            noiseSynth.volume.value = -8; noiseSynth.triggerAttackRelease(0.25); noiseSynth.volume.value = -15; 
                        } else {
                            console.warn("noiseSynth is not initialized for chopperExplosion sound.");
                        }
                        break;  
                    case 'playerExplosion': 
                        if (noiseSynth) { // Added safeguard
                            noiseSynth.triggerAttackRelease(0.5); 
                        } else {
                            console.warn("noiseSynth is not initialized for playerExplosion sound.");
                        }
                        break; 
                    case 'barrierHit': 
                        if (synth) { // Added safeguard
                            synth.triggerAttackRelease("C3", "32n", Tone.now(), 0.5); 
                        } else {
                            console.warn("synth is not initialized for barrierHit sound.");
                        }
                        break;
                    case 'ufoFlyStart': if (ufoSynth && ufoSynth.state !== "started") ufoSynth.start(); break;
                    case 'ufoFlyStop': if (ufoSynth && ufoSynth.state === "started") ufoSynth.stop(); break;
                    case 'chopperFlyStart': if (chopperSynth) chopperSynth.triggerAttack(Tone.now()); break; 
                    case 'chopperFlyStop': if (chopperSynth) chopperSynth.triggerRelease(Tone.now() + 0.1); break; 
                    case 'bombDrop': 
                        if (bombDropSynth) { // Added safeguard
                            bombDropSynth.triggerAttackRelease("G2", "8n"); 
                        } else {
                            console.warn("bombDropSynth is not initialized for bombDrop sound.");
                        }
                        break; 
                    case 'powerUpActivate': 
                        if(powerUpSound) { // Added safeguard
                            powerUpSound.triggerAttackRelease("E5", "8n"); 
                        } else {
                            console.warn("powerUpSound is not initialized for powerUpActivate sound.");
                        }
                        break; 
                    case 'scoreMultiplierPickup': 
                        if(scoreMultiplierSound) { // Added safeguard
                            scoreMultiplierSound.triggerAttackRelease("G5", "4n"); 
                        } else {
                            console.warn("scoreMultiplierSound is not initialized for scoreMultiplierPickup sound.");
                        }
                        break; 
                }
            } catch (error) { console.error("Error playing sound:", type, error); }
        }

        // --- UI UPDATES ---
        function updateScoreboard() { scoreBoard.textContent = `Score: ${score}`; }
        function updateLivesBoard() { livesBoard.textContent = `Lives: ${lives}`; }
        function updatePowerUpIndicators() { 
            if (playerHasLaser) {
                const timeRemaining = Math.max(0, Math.ceil((laserActivationTime + currentLaserDuration - Date.now()) / 1000));
                laserTimeBoard.textContent = `${currentLaserDuration === doubleLaserDuration ? "Dbl " : ""}Laser: ${timeRemaining}s`;
                laserTimeBoard.style.color = currentLaserDuration === doubleLaserDuration ? playerDoubleLaserColor : playerLaserColor;
                laserTimeBoard.style.visibility = 'visible';
            } else { laserTimeBoard.style.visibility = 'hidden'; }
            fireRateBoostIndicator.style.visibility = playerFireRateBoostActive && !playerHasLaser ? 'visible' : 'hidden'; 
            doubleShotIndicator.style.visibility = isRandomDoubleShotActive && !playerHasLaser ? 'visible' : 'hidden'; 
            scoreMultiplierIndicator.style.visibility = isScoreMultiplierActive ? 'visible' : 'hidden'; 
            waveDisplay.textContent = `Wave: ${currentWave}`; 
            updateHighScoreDisplay(); 
            // Torpedo indicator
            if (currentWave >= 4) {
                const torpReady = (Date.now() - lastTorpedoTime) > torpedoCooldown;
                torpedoIndicator.textContent = torpReady ? 'Torpedo: READY' : `Torpedo: ${Math.ceil((torpedoCooldown - (Date.now() - lastTorpedoTime))/1000)}s`;
                torpedoIndicator.style.visibility = 'visible';
            } else {
                torpedoIndicator.style.visibility = 'hidden';
            }
            // Nuclear indicator
            if (currentWave >= 6) {
                const nukeReady = (Date.now() - lastNuclearTime) > nuclearCooldown;
                nuclearIndicator.textContent = nukeReady ? 'Nuclear: READY' : `Nuclear: ${Math.ceil((nuclearCooldown - (Date.now() - lastNuclearTime))/1000)}s`;
                nuclearIndicator.style.visibility = 'visible';
            } else {
                nuclearIndicator.style.visibility = 'hidden';
            }
        }


        // --- CANVAS RESIZING ---
        function resizeCanvas() { 
            const aspectRatio = 4 / 3; let newWidth = window.innerWidth * 0.9; let newHeight = newWidth / aspectRatio;
            if (newHeight > window.innerHeight * 0.75) { newHeight = window.innerHeight * 0.75; newWidth = newHeight * aspectRatio; }
            if (newWidth > window.innerWidth * 0.95) { newWidth = window.innerWidth * 0.95; newHeight = newWidth / aspectRatio; if (newHeight > window.innerHeight * 0.75) { newHeight = window.innerHeight * 0.75; newWidth = newHeight * aspectRatio; }}
            const oldCanvasWidth = canvas.width; canvas.width = Math.floor(newWidth); canvas.height = Math.floor(newHeight);
            barrierTopY = canvas.height - playerHeight - 80; 

            if (lives <= 0 && messageBox.style.display === 'block' && !gameRunning) { ctx.clearRect(0, 0, canvas.width, canvas.height); player = player || createPlayer(); player.y = canvas.height - playerHeight - 20; player.x = Math.max(0, Math.min(player.x, canvas.width - player.width)); initBarriers(); drawPlayer(); drawInvaders(); drawBarriers(); drawUFO(); drawChopper(); return; }
            if (gameRunning || lives <= 0 || messageBox.style.display === 'none') {
                const cs = score, cl = lives, wgar = gameRunning, pla = playerHasLaser, plaT = laserActivationTime, cld = currentLaserDuration, frb = playerFireRateBoostActive, muc = missedUfoCount, rds = isRandomDoubleShotActive, rdsT = randomDoubleShotActivationTime, sma = isScoreMultiplierActive, smaT = scoreMultiplierActivationTime, cw = currentWave; 
                let uD = ufo && oldCanvasWidth > 0 ? { ...ufo, x: ufo.x * (canvas.width / oldCanvasWidth) } : (ufo ? { ...ufo } : null);
                let chD = chopper && oldCanvasWidth > 0 ? { ...chopper, x: chopper.x * (canvas.width / oldCanvasWidth) } : (chopper ? { ...chopper } : null); 
                let pX = player ? (oldCanvasWidth > 0 ? player.x * (canvas.width / oldCanvasWidth) : player.x) : (canvas.width / 2 - playerWidth / 2);
                initGame(false); score = cs; lives = cl; playerHasLaser = pla; laserActivationTime = plaT; currentLaserDuration = cld; playerFireRateBoostActive = frb; missedUfoCount = muc; isRandomDoubleShotActive = rds; randomDoubleShotActivationTime = rdsT; isScoreMultiplierActive = sma; scoreMultiplierActivationTime = smaT; currentWave = cw; 
                if (player) { player.x = pX; player.x = Math.max(0, Math.min(player.x, canvas.width - player.width)); }
                if (uD && uD.alive) { ufo = uD; if (ufo.x + ufo.width < 0) ufo.x = -ufo.width; if (ufo.x > canvas.width) ufo.x = canvas.width; }
                if (chD && chD.alive) { chopper = chD; if (chopper.x + chopper.width < 0) chopper.x = -chopper.width; if (chopper.x > canvas.width) chopper.x = canvas.width; } 
                updateScoreboard(); updateLivesBoard(); updatePowerUpIndicators();
                if (lives <= 0) { showGameOverMessage(); gameRunning = false; }
            } else { ctx.clearRect(0, 0, canvas.width, canvas.height); player = player || createPlayer(); player.y = canvas.height - playerHeight - 20; player.x = Math.max(0, Math.min(player.x, canvas.width - player.width)); initBarriers(); drawPlayer(); drawInvaders(); drawBarriers(); drawUFO(); drawChopper(); }
        } 

        // --- OBJECT CREATION ---
        function createPlayer() { return { x: canvas.width / 2 - playerWidth / 2, y: canvas.height - playerHeight - 20, width: playerWidth, height: playerHeight, color: playerHasLaser ? (currentLaserDuration === doubleLaserDuration ? playerDoubleLaserColor : playerLaserColor) : playerNormalColor }; }
        function createInvader(x,y,type){ return {x,y,width:alienWidth,height:alienHeight,color:type===1?'#f0f':(type===2?'#0ff':'#ff0'),type,alive:true};}
        function createBullet(x,y,c,vY){ return {x,y,width:bulletWidth,height:bulletHeight,color:c,velocityY:vY};}
        function createBarrierSegment(x,y){ return {x,y,width:barrierSegmentSize,height:barrierSegmentSize,color:'#0c0',hits:0,maxHits:3,alive:true};}
        function createUFO() { 
            playSound('ufoFlyStart'); 
            const dir = Math.random() < 0.5 ? 1 : -1; 
            let cUS; 
            const rsf = Math.random(); 
            if (rsf < 0.25) { cUS = (0.5 + Math.random() * 0.5) * baseUfoSpeed; } 
            else if (rsf < 0.65) { cUS = (0.9 + Math.random() * 0.4) * baseUfoSpeed; } 
            else { cUS = (1.8 + Math.random() * 1.2) * baseUfoSpeed; } 
            // 25% chance to tow banner
            ufoHasBanner = Math.random() < 0.25;
            return { x: dir === 1 ? -ufoWidth : canvas.width, y: alienOffsetTop / 2, width: ufoWidth, height: ufoHeight, speed: cUS * dir, color: ufoColor, alive: true, points: ufoPoints }; 
        }
        function createChopper() { playSound('chopperFlyStart'); const dir = Math.random() < 0.5 ? 1 : -1; return { x: dir === 1 ? -chopperWidth : canvas.width, y: chopperAltitude, width: chopperWidth, height: chopperHeight, speed: chopperSpeed * dir, color: chopperColor, alive: true, points: chopperPoints, lastBombDrop: 0 };}
        function createChopperBomb(x, y) { return { x, y, width: bombWidth, height: bombHeight, color: bombColor, speed: bombSpeed }; }
        function createScoreMultiplier() { return { x: Math.random() * (canvas.width - scoreMultiplierSize), y: Math.random() * (canvas.height / 2 - scoreMultiplierSize) + alienOffsetTop + alienRows * (alienHeight + alienPadding) + 20, size: scoreMultiplierSize, color: scoreMultiplierColor, alive: true, spawnTime: Date.now() }; }


        // --- GAME INITIALIZATION ---
        function initBarriers() { barriers = []; barrierTopY = canvas.height - playerHeight - 80; const tbW = barrierCount * barrierBlockWidth; const ts = canvas.width - tbW; const sp = ts / (barrierCount + 1); for (let i = 0; i < barrierCount; i++) { const bX = sp * (i + 1) + barrierBlockWidth * i; const segs = []; for (let r = 0; r < barrierBlockHeight / barrierSegmentSize; r++) { for (let c = 0; c < barrierBlockWidth / barrierSegmentSize; c++) { segs.push(createBarrierSegment(bX + c * barrierSegmentSize, barrierTopY + r * barrierSegmentSize)); }} barriers.push(segs);}} 
        
        function resetInvadersForNewWave() { 
            invaders = [];
            alienSpeed = alienBaseSpeed + (0.35 * (currentWave - 1)); 
            alienSpeed = Math.min(alienSpeed, 3.5); 
            currentAlienBulletSpeed = baseAlienBulletSpeed + (0.2 * (currentWave-1));
            currentAlienBulletSpeed = Math.min(currentAlienBulletSpeed, 6); 

            for (let r = 0; r < alienRows; r++) { for (let c = 0; c < alienCols; c++) { invaders.push(createInvader(alienOffsetLeft + c * (alienWidth + alienPadding), alienOffsetTop + r * (alienHeight + alienPadding), (r % 3) + 1)); }}
        }
        
        function initGame(resetWaveAndPersistentScore = true) { 
            player = createPlayer(); 
            bullets = []; alienBullets = []; chopperBombs = []; scoreMultipliers = []; 
            ufo = null; chopper = null; 
            ufoSpawnTimer = Date.now(); chopperSpawnTimer = Date.now(); lastScoreMultiplierSpawnCheck = Date.now(); 
            playSound('ufoFlyStop'); playSound('chopperFlyStop');
            alienDirection = 1; 
            if (resetWaveAndPersistentScore) { 
                currentWave = 1;
                alienBaseSpeed = 0.5;
                currentAlienBulletSpeed = 3;
            }
            alienSpeed = alienBaseSpeed + (0.1 * (currentWave > 1 ? currentWave -1 : 0)); 
            alienSpeed = Math.min(alienSpeed, 1.5);
            currentAlienBulletSpeed = baseAlienBulletSpeed + (0.2 * (currentWave > 1 ? currentWave -1 : 0));
            currentAlienBulletSpeed = Math.min(currentAlienBulletSpeed, 6);
            lastAlienShotTime = 0;
            playerHasLaser = false; isLaserBeamActive = false; laserActivationTime = 0; currentLaserDuration = 0; 
            missedUfoCount = 0; playerFireRateBoostActive = false; 
            isRandomDoubleShotActive = false; randomDoubleShotActivationTime = 0; lastRandomDoubleShotCheck = Date.now(); 
            isScoreMultiplierActive = false; scoreMultiplierActivationTime = 0; 
            updatePowerUpIndicators();
            resetInvadersForNewWave(); 
            initBarriers(); hideMessage(); 
            if (audioInitialized) { Tone.Transport.cancel(); Tone.Transport.bpm.value = baseInvaderBPM; if (invaderMoveSequence) { invaderMoveSequence.loop = true; if (invaderMoveSequence.state !== "started") invaderMoveSequence.start(0); } if (Tone.Transport.state !== "started") Tone.Transport.start(); }
        }

        // --- DRAW FUNCTIONS ---
        function drawPlayer() { if (!player) return; player.color = playerHasLaser ? (currentLaserDuration === doubleLaserDuration ? playerDoubleLaserColor : playerLaserColor) : playerNormalColor; ctx.fillStyle = player.color; ctx.beginPath(); ctx.moveTo(player.x + player.width / 2, player.y); ctx.lineTo(player.x, player.y + player.height); ctx.lineTo(player.x + player.width, player.y + player.height); ctx.closePath(); ctx.fill(); }
        function drawInvaders() { if (!Array.isArray(invaders)) return; invaders.forEach(inv => { if (inv.alive) { ctx.fillStyle = inv.color; ctx.fillRect(inv.x, inv.y, inv.width, inv.height); ctx.fillStyle = 'black'; ctx.fillRect(inv.x + inv.width * 0.2, inv.y + inv.height * 0.2, 4, 4); ctx.fillRect(inv.x + inv.width * 0.6, inv.y + inv.height * 0.2, 4, 4); }}); }
        function drawBullets() { if (!Array.isArray(bullets)) return; bullets.forEach(b => { ctx.fillStyle = b.color; ctx.fillRect(b.x, b.y, b.width, b.height); }); if (!Array.isArray(alienBullets)) return; alienBullets.forEach(b => { ctx.fillStyle = b.color; ctx.fillRect(b.x, b.y, b.width, b.height); });}
        function drawLaserBeam() { if (isLaserBeamActive && player) { ctx.fillStyle = laserColor; ctx.shadowBlur = 7; ctx.shadowColor = laserColor; ctx.fillRect(player.x + player.width / 2 - laserBeamWidth / 2, 0, laserBeamWidth, player.y); ctx.shadowBlur = 0; }}
        function drawChopper() { if (chopper && chopper.alive) { ctx.fillStyle = chopper.color; ctx.fillRect(chopper.x, chopper.y, chopper.width, chopper.height); ctx.fillRect(chopper.x + chopper.width / 2 - (chopper.width*0.7)/2, chopper.y - 5, chopper.width * 0.7, 5); if (chopper.speed > 0) { ctx.fillRect(chopper.x - 10, chopper.y + chopper.height / 4, 10, chopper.height / 2); } else { ctx.fillRect(chopper.x + chopper.width, chopper.y + chopper.height / 4, 10, chopper.height / 2); }}}
        function drawChopperBombs() { if (!Array.isArray(chopperBombs)) return; chopperBombs.forEach(bomb => { ctx.fillStyle = bomb.color; ctx.fillRect(bomb.x, bomb.y, bomb.width, bomb.height); });}
        function drawBarriers() { if (!Array.isArray(barriers)) return; barriers.forEach(bar => { if (!Array.isArray(bar)) return; bar.forEach(seg => { if (seg.alive) { const op = 1 - (seg.hits / seg.maxHits) * 0.7; ctx.fillStyle = `rgba(0, 204, 0, ${op})`; ctx.fillRect(seg.x, seg.y, seg.width, seg.height); }}); });}
        function drawUFO() { 
            if (ufo && ufo.alive) { 
                ctx.fillStyle = ufo.color; 
                ctx.beginPath(); 
                ctx.ellipse(ufo.x + ufo.width / 2, ufo.y + ufo.height / 2, ufo.width / 2, ufo.height / 2, 0, Math.PI, 2 * Math.PI, false); 
                ctx.lineTo(ufo.x + ufo.width, ufo.y + ufo.height); 
                ctx.lineTo(ufo.x, ufo.y + ufo.height); 
                ctx.closePath(); 
                ctx.fill(); 
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; 
                ctx.beginPath(); 
                ctx.ellipse(ufo.x + ufo.width / 2, ufo.y + ufo.height * 0.4, ufo.width * 0.3, ufo.height * 0.25, 0, 0, 2 * Math.PI); 
                ctx.fill(); 
                // Draw banner if present
                if (ufoHasBanner) {
                    ctx.save();
                    ctx.font = ufoBannerFont;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    const bannerW = ctx.measureText(ufoBannerText).width + 32;
                    const bannerH = 28;
                    const bannerX = ufo.x + ufo.width / 2 - bannerW / 2;
                    const bannerY = ufo.y + ufo.height + 8;
                    // Banner background
                    ctx.fillStyle = ufoBannerBg;
                    ctx.fillRect(bannerX, bannerY, bannerW, bannerH);
                    // Banner border
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(bannerX, bannerY, bannerW, bannerH);
                    // Banner text
                    ctx.fillStyle = ufoBannerColor;
                    ctx.fillText(ufoBannerText, ufo.x + ufo.width / 2, bannerY + 6);
                    ctx.restore();
                }
            }
        }
        function drawScoreMultipliers() { scoreMultipliers.forEach(sm => { if (sm.alive) { ctx.fillStyle = sm.color; ctx.font = `${sm.size * 1.5}px "Press Start 2P"`; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText('‚≠ê', sm.x + sm.size / 2, sm.y + sm.size / 2); }}); }
        function drawHeart() {
            if (heart && heart.alive) {
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(heart.x + heartWidth / 2, heart.y + heartHeight / 2);
                ctx.bezierCurveTo(heart.x + heartWidth / 2, heart.y, heart.x, heart.y, heart.x, heart.y + heartHeight / 3);
                ctx.bezierCurveTo(heart.x, heart.y + heartHeight, heart.x + heartWidth / 2, heart.y + heartHeight, heart.x + heartWidth / 2, heart.y + heartHeight * 0.75);
                ctx.bezierCurveTo(heart.x + heartWidth / 2, heart.y + heartHeight, heart.x + heartWidth, heart.y + heartHeight, heart.x + heartWidth, heart.y + heartHeight / 3);
                ctx.bezierCurveTo(heart.x + heartWidth, heart.y, heart.x + heartWidth / 2, heart.y, heart.x + heartWidth / 2, heart.y + heartHeight / 2);
                ctx.closePath();
                ctx.fillStyle = heartColor;
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 8;
                ctx.fill();
                ctx.restore();
            }
        }
        // Draw big bomb
        function drawBigBomb() {
            if (bigBomb && bigBomb.alive) {
                ctx.save();
                ctx.beginPath();
                ctx.arc(bigBomb.x + bigBomb.width / 2, bigBomb.y + bigBomb.height / 2, bigBomb.width / 2, 0, 2 * Math.PI);
                ctx.fillStyle = bigBombColor;
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 12;
                ctx.fill();
                ctx.restore();
                // Draw fuse
                ctx.save();
                ctx.strokeStyle = '#f00';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(bigBomb.x + bigBomb.width / 2, bigBomb.y);
                ctx.lineTo(bigBomb.x + bigBomb.width / 2, bigBomb.y - 18);
                ctx.stroke();
                ctx.restore();
            }
            // Draw explosion
            if (bigBombExplosion) {
                const elapsed = Date.now() - bigBombExplosionTime;
                if (elapsed < bigBombExplosionDuration) {
                    ctx.save();
                    ctx.globalAlpha = 0.7 * (1 - elapsed / bigBombExplosionDuration);
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) * (elapsed / bigBombExplosionDuration), 0, 2 * Math.PI);
                    ctx.fillStyle = '#ff0';
                    ctx.shadowColor = '#fff';
                    ctx.shadowBlur = 40;
                    ctx.fill();
                    ctx.restore();
                } else {
                    bigBombExplosion = false;
                }
            }
        }


        // --- UPDATE LOGIC ---
        function updatePlayer() { if (!player || !gameRunning) return; if (keys.ArrowLeft && player.x > 0) player.x -= playerSpeed; if (keys.ArrowRight && player.x < canvas.width - player.width) player.x += playerSpeed; }
        function updateBullets() { if (!gameRunning) return; for (let i = bullets.length - 1; i >= 0; i--) { bullets[i].y += bullets[i].velocityY; if (bullets[i].y + bullets[i].height < 0) bullets.splice(i, 1); } for (let i = alienBullets.length - 1; i >= 0; i--) { alienBullets[i].y += currentAlienBulletSpeed; if (alienBullets[i].y > canvas.height) alienBullets.splice(i, 1); }}
        
        function updatePowerUpsStatus() { 
            if (playerHasLaser) { if (Date.now() > laserActivationTime + currentLaserDuration) { playerHasLaser = false; isLaserBeamActive = false; if(player) player.color = playerNormalColor; currentLaserDuration = 0; }}
            if (isLaserBeamActive && Date.now() > laserBeamEndTime) { isLaserBeamActive = false; }
            if (isRandomDoubleShotActive && Date.now() > randomDoubleShotActivationTime + randomDoubleShotDuration) { isRandomDoubleShotActive = false; }
            if (isScoreMultiplierActive && Date.now() > scoreMultiplierActivationTime + scoreMultiplierDuration) { isScoreMultiplierActive = false; } 
            updatePowerUpIndicators();
        }
        
        function updateInvaderSoundTempo() {
            if (!gameRunning || !audioInitialized || !Array.isArray(invaders) || !invaderMoveSequence) return;
            const aliveInvaders = invaders.filter(inv => inv.alive);
            if (aliveInvaders.length === 0) { if (invaderMoveSequence.state === "started") invaderMoveSequence.stop(); return; }
            let lowestY = 0; aliveInvaders.forEach(inv => { if (inv.y + inv.height > lowestY) lowestY = inv.y + inv.height; });
            const proximityRatio = Math.min(1, lowestY / (canvas.height - playerHeight * 2));
            const scarcityRatio = (totalInvaders - aliveInvaders.length) / (totalInvaders > 1 ? totalInvaders - 1 : 1);
            const combinedFactor = (proximityRatio * 0.6) + (scarcityRatio * 0.4); 
            let newBPM = baseInvaderBPM + (maxInvaderBPM - baseInvaderBPM) * combinedFactor;
            newBPM = Math.max(baseInvaderBPM, Math.min(maxInvaderBPM, newBPM));
            Tone.Transport.bpm.value = newBPM;
            if (invaderMoveSequence.state !== "started" && aliveInvaders.length > 0) invaderMoveSequence.start(0);
            if (Tone.Transport.state !== "started" && aliveInvaders.length > 0) Tone.Transport.start();
        }

        // ‚ú® Gemini API Integration: Generate Alien Taunts
        async function generateAlienTaunt() {
            if (!gameRunning) return;

            const prompt = "Generate a short, menacing, and slightly arrogant taunt from a space alien in a classic Space Invaders game. Keep it under 50 characters.";
            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = { contents: chatHistory };
            const apiKey = ""; // Canvas will provide this at runtime
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    displayAlienTaunt(text);
                } else {
                    console.warn("Gemini API did not return a valid taunt.");
                }
            } catch (error) {
                console.error("Error calling Gemini API for taunt:", error);
            }
        }

        function displayAlienTaunt(tauntText) {
            alienTauntBox.textContent = tauntText;
            alienTauntBox.style.display = 'block';
            lastTauntTime = Date.now();

            // Clear any existing timeout to prevent overlapping taunts
            if (tauntTimeoutId) {
                clearTimeout(tauntTimeoutId);
            }
            tauntTimeoutId = setTimeout(() => {
                alienTauntBox.style.display = 'none';
            }, tauntDisplayDuration);
        }

        function updateInvaders() {
            if (!gameRunning || !Array.isArray(invaders)) return;
            let moveDown = false; const aliveInvaders = invaders.filter(inv => inv.alive);
            
            if (aliveInvaders.length === 0 && gameRunning) { 
                gameRunning = false; 
                currentWave++;
                updatePowerUpIndicators(); 
                if ((currentWave -1) % 2 === 0 && currentWave > 1) { 
                    initBarriers(); 
                }
                showMessage(`Wave ${currentWave -1} Cleared!`, `Get Ready for Wave ${currentWave}`, "Next Wave", () => {
                    resetInvadersForNewWave(); 
                    gameRunning = true; 
                });
                return; 
            } 
            
            aliveInvaders.forEach(invader => { 
                invader.x += alienSpeed * alienDirection; 
                if (invader.x + invader.width > canvas.width || invader.x < 0) {moveDown = true;} 
                if (barrierTopY && invader.y + invader.height >= barrierTopY) {
                    if (Array.isArray(barriers)) {
                        for (let b = 0; b < barriers.length; b++) { if (!Array.isArray(barriers[b])) continue;
                            for (let s = barriers[b].length - 1; s >= 0; s--) { const segment = barriers[b][s];
                                if (segment.alive && invader.x < segment.x + segment.width && invader.x + invader.width > segment.x && invader.y < segment.y + segment.height && invader.y + invader.height > segment.y) { 
                                    segment.alive = false; playSound('barrierHit'); 
                                }}}}}
                if (player && invader.y + invader.height >= player.y ) { gameOver(); return; } 
                else if (!player && invader.y + invader.height >= canvas.height - playerHeight - 20) { gameOver(); return; }
            });
            if (!gameRunning) return; 
            if (moveDown) { alienDirection *= -1; invaders.forEach(inv => { if (inv.alive) inv.y += alienDropDistance; }); }
            const ct = Date.now();
            if (ct - lastAlienShotTime > alienShootInterval && aliveInvaders.length > 0) {
                const bI = []; for(let c = 0; c < alienCols; c++) { let l = null; for(let r = alienRows -1; r >=0; r--) { const i = invaders[r * alienCols + c]; if(i && i.alive) { l = i; break; }} if(l) bI.push(l); }
                if (bI.length > 0) { const s = bI[Math.floor(Math.random() * bI.length)]; alienBullets.push(createBullet(s.x + s.width / 2 - bulletWidth / 2, s.y + s.height, '#f00', currentAlienBulletSpeed)); lastAlienShotTime = ct; } 
                // ‚ú® Trigger alien taunt when an alien shoots (with a cooldown)
                if (ct - lastTauntTime > tauntInterval) {
                    generateAlienTaunt();
                }
            } else if (aliveInvaders.length > 0 && ct - lastTauntTime > tauntInterval * 2 && Math.random() < 0.05) { // Periodic taunt if no shooting
                generateAlienTaunt();
            }
        }
        function updateUFO() { 
            if (!gameRunning) return; const ct = Date.now(); 
            let currentUfoSpawnInterval = ufoSpawnInterval; let currentUfoSpawnProbability = 0.4; 
            if (isRandomDoubleShotActive) { currentUfoSpawnInterval = ufoSpawnInterval / 2.5; currentUfoSpawnProbability = 0.65; } 
            if (!ufo && ct - ufoSpawnTimer > currentUfoSpawnInterval) { if (Math.random() < currentUfoSpawnProbability) ufo = createUFO(); ufoSpawnTimer = ct; } 
            if (ufo && ufo.alive) { ufo.x += ufo.speed; if ((ufo.speed > 0 && ufo.x > canvas.width) || (ufo.speed < 0 && ufo.x + ufo.width < 0)) { ufo = null; playSound('ufoFlyStop'); missedUfoCount++; if (missedUfoCount >= 2 && !playerHasLaser && !isRandomDoubleShotActive) { playerFireRateBoostActive = true; updatePowerUpIndicators(); }}}
        }
        function updateChopper() { if (!gameRunning) return; const currentTime = Date.now(); if (!chopper && currentTime - chopperSpawnTimer > chopperSpawnInterval) { if (Math.random() < 0.25) { chopper = createChopper(); } chopperSpawnTimer = currentTime; } if (chopper && chopper.alive) { chopper.x += chopper.speed; if ((chopper.speed > 0 && chopper.x > canvas.width) || (chopper.speed < 0 && chopper.x + chopper.width < 0)) { chopper = null; playSound('chopperFlyStop'); } else { if (currentTime - chopper.lastBombDrop > chopperBombDropInterval) { chopperBombs.push(createChopperBomb(chopper.x + chopper.width / 2 - bombWidth / 2, chopper.y + chopper.height)); chopper.lastBombDrop = currentTime; playSound('bombDrop'); }}} for (let i = chopperBombs.length - 1; i >= 0; i--) { chopperBombs[i].y += bombSpeed; if (chopperBombs[i].y > canvas.height) { chopperBombs.splice(i, 1); }}}
        function updateScoreMultipliers() {
            if (!gameRunning) return; const now = Date.now();
            if (scoreMultipliers.length === 0 && now - lastScoreMultiplierSpawnCheck > scoreMultiplierSpawnInterval) { if (Math.random() < scoreMultiplierSpawnChance) { scoreMultipliers.push(createScoreMultiplier()); } lastScoreMultiplierSpawnCheck = now; }
            for (let i = scoreMultipliers.length - 1; i >= 0; i--) { if (now - scoreMultipliers[i].spawnTime > scoreMultiplierDespawnTime) { scoreMultipliers[i].alive = false; scoreMultipliers.splice(i, 1); }}
        }


        // --- COLLISION DETECTION ---
        function checkLaserBeamCollisions() {  if (!isLaserBeamActive || !player) return; const bCX = player.x + player.width / 2; const bL = bCX - laserBeamWidth / 2; const bR = bCX + laserBeamWidth / 2; if (Array.isArray(invaders)) { invaders.forEach(inv => { if (inv.alive && bL < inv.x + inv.width && bR > inv.x && player.y > inv.y) { inv.alive = false; score += isScoreMultiplierActive ? (10 * inv.type * scoreMultiplierValue) : (10 * inv.type); updateScoreboard(); playSound('invaderExplosion'); }});} if (Array.isArray(barriers)) { barriers.forEach(bar => { if (!Array.isArray(bar)) return; bar.forEach(seg => { if (seg.alive && bL < seg.x + seg.width && bR > seg.x && player.y > seg.y ) { seg.alive = false; }}); });}}
        function checkCollisions() {
            if (!gameRunning) return;
            // Player bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i]; if (!b) continue; let bRmv = false;
                if (Array.isArray(invaders)) { for (let j = invaders.length - 1; j >= 0; j--) { if (invaders[j].alive && b.x < invaders[j].x + invaders[j].width && b.x + b.width > invaders[j].x && b.y < invaders[j].y + invaders[j].height && b.y + b.height > invaders[j].y) { invaders[j].alive = false; score += isScoreMultiplierActive ? (10 * invaders[j].type * scoreMultiplierValue) : (10 * invaders[j].type); updateScoreboard(); alienSpeed += speedIncreasePerKill; if (!b.isTorpedo) { bullets.splice(i, 1); bRmv = true; } playSound('invaderExplosion'); break; }}}
                if (bRmv) continue;
                if (ufo && ufo.alive && b.x < ufo.x + ufo.width && b.x + b.width > ufo.x && b.y < ufo.y + ufo.height && b.y + b.height > ufo.y) { ufo.alive = false; score += isScoreMultiplierActive ? (ufo.points * scoreMultiplierValue) : ufo.points; updateScoreboard(); if (!playerHasLaser || currentLaserDuration !== doubleLaserDuration) { playerHasLaser = true; laserActivationTime = Date.now(); currentLaserDuration = standardLaserDuration; if(player) player.color = playerLaserColor; } missedUfoCount = 0; playerFireRateBoostActive = false; isRandomDoubleShotActive = false; updatePowerUpIndicators(); if (!b.isTorpedo) { bullets.splice(i, 1); bRmv = true; } ufo = null; playSound('ufoExplosion'); playSound('ufoFlyStop'); }
                if (bRmv) continue;
                if (chopper && chopper.alive && b.x < chopper.x + chopper.width && b.x + b.width > chopper.x && b.y < chopper.y + chopper.height && b.y + b.height > chopper.y) { chopper.alive = false; score += isScoreMultiplierActive ? (chopper.points * scoreMultiplierValue) : chopper.points; updateScoreboard(); playerHasLaser = true; laserActivationTime = Date.now(); currentLaserDuration = doubleLaserDuration; if(player) player.color = playerDoubleLaserColor; missedUfoCount = 0; playerFireRateBoostActive = false; isRandomDoubleShotActive = false; updatePowerUpIndicators(); if (!b.isTorpedo) { bullets.splice(i, 1); bRmv = true; } chopper = null; playSound('chopperExplosion'); playSound('chopperFlyStop'); }
                if (bRmv) continue;
                if (Array.isArray(barriers)) { for (let bi = 0; bi < barriers.length; bi++) { if (!Array.isArray(barriers[bi])) continue; for (let s = barriers[bi].length - 1; s >= 0; s--) { const seg = barriers[bi][s]; if (seg.alive && b.x < seg.x + seg.width && b.x + b.width > seg.x && b.y < seg.y + seg.height && b.y + b.height > seg.y) { seg.hits++; if (seg.hits >= seg.maxHits) seg.alive = false; if (!b.isTorpedo) { bullets.splice(i, 1); bRmv = true; } playSound('barrierHit'); break; }} if (bRmv) break; }}
            }
            // Player vs Score Multiplier
            if(player && Array.isArray(scoreMultipliers)) { for (let i = scoreMultipliers.length - 1; i >= 0; i--) { const sm = scoreMultipliers[i]; if (sm.alive && player.x < sm.x + sm.size && player.x + player.width > sm.x && player.y < sm.y + sm.size && player.y + player.height > sm.y) { isScoreMultiplierActive = true; scoreMultiplierActivationTime = Date.now(); playSound('scoreMultiplierPickup'); scoreMultipliers.splice(i, 1); updatePowerUpIndicators(); break; }}}
            
            if (!player) return; 
            // Alien bullets vs Player
            for (let i = alienBullets.length - 1; i >= 0; i--) { 
                const alienBullet = alienBullets[i]; 
                if (alienBullet.x < player.x + player.width && alienBullet.x + alienBullet.width > player.x && alienBullet.y < player.y + player.height && alienBullet.y + alienBullet.height > player.y) { 
                    alienBullets.splice(i, 1); lives--; updateLivesBoard(); 
                    playerHasLaser = false; isLaserBeamActive = false; if(player) player.color = playerNormalColor; currentLaserDuration = 0; missedUfoCount = 0; playerFireRateBoostActive = false; isRandomDoubleShotActive = false; isScoreMultiplierActive = false; updatePowerUpIndicators(); 
                    playSound('playerExplosion'); if (lives <= 0) { gameOver(); return; } canvas.classList.add('shake'); setTimeout(() => canvas.classList.remove('shake'), 150); break; 
                }
                // ALIEN BULLET VS BARRIER:
                let alienBulletRemoved = false;
                if (Array.isArray(barriers)) {
                    for (let bi = 0; bi < barriers.length; bi++) { if (!Array.isArray(barriers[bi])) continue;
                        for (let s = barriers[bi].length - 1; s >= 0; s--) { const segment = barriers[bi][s];
                            if (segment.alive && alienBullet && 
                                alienBullet.x < segment.x + segment.width && alienBullet.x + alienBullet.width > segment.x &&
                                alienBullet.y < segment.y + segment.height && alienBullet.y + alienBullet.height > segment.y) {
                                segment.hits++; if (segment.hits >= segment.maxHits) segment.alive = false;
                                alienBullets.splice(i, 1); alienBulletRemoved = true; playSound('barrierHit'); break; 
                            }
                        } if (alienBulletRemoved) break; 
                    }
                }
                if (alienBulletRemoved) continue; 
            }

            // Chopper bombs vs Player
            for (let i = chopperBombs.length - 1; i >= 0; i--) { const bomb = chopperBombs[i]; if (player && bomb.x < player.x + player.width && bomb.x + bomb.width > player.x && bomb.y < player.y + player.height && bomb.y + bomb.height > player.y) { chopperBombs.splice(i, 1); lives--; updateLivesBoard(); playerHasLaser = false; isLaserBeamActive = false; if(player) player.color = playerNormalColor; currentLaserDuration = 0; missedUfoCount = 0; playerFireRateBoostActive = false; isRandomDoubleShotActive = false; isScoreMultiplierActive = false; updatePowerUpIndicators(); playSound('playerExplosion'); if (lives <= 0) { gameOver(); return; } canvas.classList.add('shake'); setTimeout(() => canvas.classList.remove('shake'), 150); break; } let bombRemoved = false; if (Array.isArray(barriers)) { for (let bi = 0; bi < barriers.length; bi++) { if (!Array.isArray(barriers[bi])) continue; for (let s = barriers[bi].length - 1; s >= 0; s--) { const seg = barriers[bi][s]; if (seg.alive && bomb.x < seg.x + seg.width && bomb.x + bomb.width > seg.x && bomb.y < seg.y + seg.height && bomb.y + bomb.height > seg.y) { seg.alive = false; chopperBombs.splice(i,1); bombRemoved = true; playSound('barrierHit'); break;}} if (bombRemoved) break;}}}

            // Player catches heart
            if (heart && heart.alive && player && player.x < heart.x + heart.width && player.x + player.width > heart.x && player.y < heart.y + heart.height && player.y + player.height > heart.y) {
                lives++;
                updateLivesBoard();
                heart = null;
                playSound('powerUpActivate');
            }
            // Player hits big bomb
            if (bigBomb && bigBomb.alive && player && player.x < bigBomb.x + bigBomb.width && player.x + player.width > bigBomb.x && player.y < bigBomb.y + bigBomb.height && player.y + player.height > bigBomb.y) {
                // Explode armada
                invaders.forEach(inv => { if (inv.alive) { inv.alive = false; score += 10 * inv.type; }});
                updateScoreboard();
                bigBombExplosion = true;
                bigBombExplosionTime = Date.now();
                bigBomb = null;
                playSound('playerExplosion');
            }
        }

        // --- GAME STATE & MESSAGES ---
        // Wrapper function to handle audio initialization before starting the game
        async function startGameAndInitializeAudio() {
            if (!audioInitialized) {
                await initializeAudio();
            }
            score = 0; lives = 3; 
            updateScoreboard(); updateLivesBoard(); updatePowerUpIndicators();
            initGame(true); 
            gameRunning = true; 
            requestAnimationFrame(gameLoop); 
        }

        function showMessage(title, text, buttonText, onButtonClick) { messageTitle.textContent = title; messageText.innerHTML = text; const nB = messageButton.cloneNode(true); nB.textContent = buttonText; if (messageButton.parentNode) messageButton.parentNode.replaceChild(nB, messageButton); messageButton = nB; messageBox.style.display = 'block'; messageButton.onclick = () => { hideMessage(); if (onButtonClick) onButtonClick(); };}
        function hideMessage() { messageBox.style.display = 'none'; }
        function showGameOverMessage() { 
            saveHighScore(score); 
            if(finalScoreDisplay) finalScoreDisplay.textContent = score; 
            showMessage("Game Over", `Final score: <span id="finalScore">${score}</span><br>Wave Reached: ${currentWave}`, "Restart", () => { 
                score = 0; lives = 3; 
                updateScoreboard(); updateLivesBoard(); updatePowerUpIndicators(); 
                initGame(true); 
                gameRunning = true; requestAnimationFrame(gameLoop); 
            });
        }
        function gameOver() { 
            gameRunning = false; 
            playerHasLaser = false; isLaserBeamActive = false; laserActivationTime = 0; currentLaserDuration = 0; 
            missedUfoCount = 0; playerFireRateBoostActive = false; 
            isRandomDoubleShotActive = false; isScoreMultiplierActive = false; 
            updatePowerUpIndicators(); 
            playSound('ufoFlyStop'); playSound('chopperFlyStop'); 
            if(audioInitialized && invaderMoveSequence && invaderMoveSequence.state === "started") invaderMoveSequence.stop(); 
            if(audioInitialized && Tone.Transport.state === "started") {Tone.Transport.stop(); Tone.Transport.cancel();} 
            showGameOverMessage(); 
        }
        function gameWon() { // This is effectively an "all waves cleared" state if you define a max wave
            saveHighScore(score); 
            gameRunning = false; 
            playerHasLaser = false; isLaserBeamActive = false; laserActivationTime = 0; currentLaserDuration = 0; 
            missedUfoCount = 0; playerFireRateBoostActive = false; isRandomDoubleShotActive = false; isScoreMultiplierActive = false; 
            updatePowerUpIndicators(); 
            playSound('ufoFlyStop'); playSound('chopperFlyStop'); 
            if(audioInitialized && invaderMoveSequence && invaderMoveSequence.state === "started") invaderMoveSequence.stop(); 
            if(audioInitialized && Tone.Transport.state === "started") {Tone.Transport.stop(); Tone.Transport.cancel();} 
            if(finalScoreDisplay) finalScoreDisplay.textContent = score; 
            showMessage("You Cleared All Waves!", `Final Score: <span id="finalScore">${score}</span>`, "Play Again", () => { 
                score = 0; lives = 3; 
                updateScoreboard(); updateLivesBoard(); 
                initGame(true); 
                gameRunning = true; requestAnimationFrame(gameLoop); 
            });
        }

        // --- GAME LOOP ---
        function gameLoop() {
            if (!gameRunning) { requestAnimationFrame(gameLoop); return; } 
            
            const now = Date.now();
            // Big bomb drop logic
            if (!bigBomb && now - lastBigBombDropTime > bigBombDropInterval) {
                bigBomb = { x: Math.random() * (canvas.width - bigBombWidth), y: -bigBombHeight, width: bigBombWidth, height: bigBombHeight, alive: true };
                lastBigBombDropTime = now;
            }
            if (bigBomb && bigBomb.alive) {
                bigBomb.y += 3.2; // bomb fall speed
                if (bigBomb.y > canvas.height) bigBomb = null;
            }
            if (!playerHasLaser && !isRandomDoubleShotActive && now - lastRandomDoubleShotCheck > randomDoubleShotCheckInterval) { if (Math.random() < randomDoubleShotChance) { isRandomDoubleShotActive = true; randomDoubleShotActivationTime = now; playSound('powerUpActivate'); } lastRandomDoubleShotCheck = now; }
            if (!isScoreMultiplierActive && scoreMultipliers.length === 0 && now - lastScoreMultiplierSpawnCheck > scoreMultiplierSpawnInterval) { if (Math.random() < scoreMultiplierSpawnChance) { scoreMultipliers.push(createScoreMultiplier()); } lastScoreMultiplierSpawnCheck = now; }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            updatePlayer(); updateBullets(); updatePowerUpsStatus(); 
            updateInvaders(); updateUFO(); updateChopper(); updateScoreMultipliers(); 
            updateInvaderSoundTempo(); 
            if (!gameRunning) { requestAnimationFrame(gameLoop); return; } 
            if (isLaserBeamActive) checkLaserBeamCollisions();
            checkCollisions(); 
            if (!gameRunning) { requestAnimationFrame(gameLoop); return; } 
            drawPlayer(); drawInvaders(); drawBullets(); if (isLaserBeamActive) drawLaserBeam(); 
            drawChopper(); drawChopperBombs(); drawScoreMultipliers(); 
            drawBarriers(); drawUFO();
            drawHeart();
            drawBigBomb(); // draw the big bomb if present
            requestAnimationFrame(gameLoop);
        }

        // --- EVENT HANDLERS & INITIAL SETUP ---
        async function handleFire() { // Made async
            if (gameRunning && player) {
                // Nuclear (Wave 6+)
                if (currentWave >= 6 && keys.N) {
                    if (Date.now() - lastNuclearTime > nuclearCooldown) {
                        // Nuclear: clear all invaders
                        invaders.forEach(inv => { if (inv.alive) { inv.alive = false; score += 10 * inv.type; }});
                        updateScoreboard();
                        lastNuclearTime = Date.now();
                        updatePowerUpIndicators();
                        playSound('playerExplosion'); // Use a big sound for nuke
                        return;
                    }
                }
                // Torpedo (Wave 4+)
                if (currentWave >= 4 && keys.T) {
                    if (Date.now() - lastTorpedoTime > torpedoCooldown) {
                        bullets.push({ x: player.x + player.width / 2 - torpedoWidth / 2, y: player.y, width: torpedoWidth, height: torpedoHeight, color: torpedoColor, velocityY: -torpedoSpeed, isTorpedo: true });
                        lastTorpedoTime = Date.now();
                        updatePowerUpIndicators();
                        playSound('playerShoot');
                        return;
                    }
                }
                // Wave 3: Intermittent laser+double
                if (currentWave === 3) {
                    const now = Date.now();
                    if (!window._wave3LaserTimer) window._wave3LaserTimer = now;
                    if (!window._wave3LaserActive) window._wave3LaserActive = false;
                    if (now - window._wave3LaserTimer > 10000) {
                        window._wave3LaserActive = true;
                        window._wave3LaserTimer = now;
                        setTimeout(() => { window._wave3LaserActive = false; }, 3000);
                    }
                    if (window._wave3LaserActive) {
                        if (playerHasLaser && !isLaserBeamActive) {
                            isLaserBeamActive = true; laserBeamEndTime = Date.now() + laserBeamVisualDuration; playSound('laserShoot');
                        } else {
                            // Always double barrel
                            if (bullets.length < maxNormalBullets + 1) {
                                bullets.push(createBullet(player.x + player.width / 2 - bulletWidth / 2 - doubleShotBulletOffsetX, player.y, normalBulletColor, -bulletSpeed));
                                bullets.push(createBullet(player.x + player.width / 2 - bulletWidth / 2 + doubleShotBulletOffsetX, player.y, normalBulletColor, -bulletSpeed));
                                playSound('playerShoot');
                            }
                        }
                        return;
                    }
                }
                // Wave 2+: Always double barrel
                if (currentWave >= 2) {
                    if (playerHasLaser && !isLaserBeamActive) {
                        isLaserBeamActive = true; laserBeamEndTime = Date.now() + laserBeamVisualDuration; playSound(currentLaserDuration === doubleLaserDuration ? 'doubleLaserShoot' : 'laserShoot');
                    } else {
                        if (bullets.length < maxNormalBullets + 1) {
                            bullets.push(createBullet(player.x + player.width / 2 - bulletWidth / 2 - doubleShotBulletOffsetX, player.y, normalBulletColor, -bulletSpeed));
                            bullets.push(createBullet(player.x + player.width / 2 - bulletWidth / 2 + doubleShotBulletOffsetX, player.y, normalBulletColor, -bulletSpeed));
                            playSound('playerShoot');
                        }
                    }
                    return;
                }
                // Default (wave 1)
                if (playerHasLaser && !isLaserBeamActive) { isLaserBeamActive = true; laserBeamEndTime = Date.now() + laserBeamVisualDuration; playSound(currentLaserDuration === doubleLaserDuration ? 'doubleLaserShoot' : 'laserShoot'); 
                } else if (isRandomDoubleShotActive && !playerHasLaser) { 
                    let currentMax = playerFireRateBoostActive ? maxBoostedBullets : maxNormalBullets;
                    if (bullets.length < currentMax) {
                         bullets.push(createBullet(player.x + player.width / 2 - bulletWidth / 2, player.y, normalBulletColor, -bulletSpeed)); 
                         playSound('playerShoot'); 
                    }
                } else if (!playerHasLaser) { 
                    let currentMax = playerFireRateBoostActive ? maxBoostedBullets : maxNormalBullets;
                    if (bullets.length < currentMax) {
                         bullets.push(createBullet(player.x + player.width / 2 - bulletWidth / 2, player.y, normalBulletColor, -bulletSpeed)); 
                         playSound('playerShoot'); 
                    }
                }
            } else if (!gameRunning && messageBox.style.display === 'block' && messageButton.textContent.toLowerCase().includes("start")) {
                if (!audioInitialized) await initializeAudio(); // Await here
                messageButton.click(); 
            }
        }
        window.addEventListener('keydown', async (e) => { // Made async
            if (keys.hasOwnProperty(e.key)) keys[e.key] = true; 
            if (e.key === ' ' || e.key === 'Spacebar') { e.preventDefault(); await handleFire(); } // Await handleFire
            if (e.key.toUpperCase() === 'T') { keys.T = true; await handleFire(); keys.T = false; } // Await handleFire
            if (e.key.toUpperCase() === 'N') { keys.N = true; await handleFire(); keys.N = false; } // Await handleFire
            if (!gameRunning && (e.key === 'ArrowLeft' || e.key === 'ArrowRight') && messageBox.style.display === 'block' && messageButton.textContent.toLowerCase().includes("start")) { 
                if (!audioInitialized) { 
                    await initializeAudio(); // Await here
                }
                messageButton.click(); 
            }
        }); 
        window.addEventListener('keyup', (e) => { if (keys.hasOwnProperty(e.key)) keys[e.key] = false; });
        const tL = document.getElementById('touchLeft'), tR = document.getElementById('touchRight'), tF = document.getElementById('touchFire'), tCD = document.getElementById('touchControls');
        if (('ontouchstart' in window) || (navigator.maxTouchPoints > 0)) { 
            tCD.style.display = 'flex'; 
            tL.addEventListener('touchstart', async (e) => { e.preventDefault(); keys.ArrowLeft = true; await initializeAudio(); }, { passive: false }); // MODIFIED to await initializeAudio
            tL.addEventListener('touchend', (e) => { e.preventDefault(); keys.ArrowLeft = false; }, { passive: false }); // MODIFIED
            tR.addEventListener('touchstart', async (e) => { e.preventDefault(); keys.ArrowRight = true; await initializeAudio(); }, { passive: false }); // MODIFIED to await initializeAudio
            tR.addEventListener('touchend', (e) => { e.preventDefault(); keys.ArrowRight = false; }, { passive: false }); // MODIFIED
            tF.addEventListener('touchstart', async (e) => { e.preventDefault(); await handleFire(); }, { passive: false }); // MODIFIED to await handleFire
        } 

        window.addEventListener('resize', resizeCanvas);
        
        loadHighScore(); 
        
        resizeCanvas(); 
        // Initial game start message now uses the new wrapper function
        showMessage("Space Invaders", "Waves, Power-Ups & More!<br>Press Space/Fire or Move to Start!", "Start Game", startGameAndInitializeAudio);
    </script>
</body>
</html>
